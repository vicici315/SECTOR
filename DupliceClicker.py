# 将图标转成二进制代码import sysimport statimport shutil# import subprocess# import threadingimport icondata# from cryptography.fernet import Fernetimport redisimport osfrom configparser import ConfigParserimport base64import wximport wx.gridimport wx.grid as gridlibimport ioimport timeimport jsonimport refrom cryptography.fernet import Fernet# import binasciiimport hashlibfrom collections import defaultdictsetkey = b'j49uKF1BZJrxFoq6pp-g4_jH8azUwzpN8MZM3O4aATc='cipher = Fernet(setkey)conf = ConfigParser()setPath = os.getcwd()+'\\PrinterSetting.ini'pcount = 0if os.path.exists(setPath):    conf.read_file(open(setPath, encoding='utf-8'))if not conf.has_section('SETTINGS'):    conf.add_section('SETTINGS')if not conf.has_section('set_DS'):    conf.add_section('set_DS')if not conf.has_section('set_DS_t'):    conf.add_section('set_DS_t')if not conf.has_section('PATH_DS'):    conf.add_section('PATH_DS')if not conf.has_section('search_text'):    conf.add_section('search_text')if not conf.has_section('FS'):    conf.add_section('FS')ALLDB = []if not conf.has_option('set_DS', 'chachong_to_redis'):    conf.set('set_DS', 'chachong_to_redis', '')try:    pcount=int(conf.get('set_DS','path_count'))except:    conf.set('set_DS', 'path_count','0')username = os.getlogin()if conf.has_option('set_DS', 'HOST'):    s_host = conf.get('set_DS', 'HOST')else:    conf.set('set_DS', 'HOST', '192.168.17.99')    s_host = '192.168.17.99'if conf.has_option('SETTINGS','dbid'):    encrypted_integer = conf.get('SETTINGS','dbid')    if len(encrypted_integer)<=2:        dblod = 1        encrypted = cipher.encrypt('1'.encode('utf-8'))        conf.set('SETTINGS','dbid',str(encrypted.decode('utf-8')))    else:        encrypted_integer = encrypted_integer.encode('utf-8')        dblod=int(cipher.decrypt(encrypted_integer))else:    dblod = 1    encrypted = cipher.encrypt('1'.encode('utf-8'))    conf.set('SETTINGS','dbid',str(encrypted.decode('utf-8')))R_Data = dict() #预读取数据NET = FalseDBSET = dblodsearch_count = Falseconf.write(open(setPath, 'w+', encoding="utf-8"))vvv = 23v2='.03'FirstUp = FalseChachong = '点击左边行数字选择整行，Ctrl+F 可打开文件目录 并复制文件名，可以在文件搜索直接 Ctrl+V 粘贴定位该文件  (Ctrl+O 打开文件) (Alt+D 删除选中数据及文件) (Ctrl+Alt+A 选择重复, Ctrl+Alt+S 排除独件, Ctrl+Alt+Shift+A 选择大于指定M的, Ctrl+Alt+Shift+G 选择大于1G, Ctrl+I 反选)'NormalTex = '点击左边行数字选择整行，Ctrl+F 可打开文件目录 并复制文件名，可以在文件搜索直接 Ctrl+V 粘贴定位该文件 (Ctrl+O 打开文件) (Alt+D 删除选中数据及文件) (Ctrl+Alt+Shift+A 选择大于指定M的, Ctrl+Alt+Shift+G 选择大于1G, Ctrl+I 反选)'class MySecondaryDialog(wx.Dialog):  #使用Dialog，实现窗口打开时锁定主窗口    def __init__(self, parent, title, text, showedit, pas, ipdb='ip'):        super(MySecondaryDialog, self).__init__(parent, title=title, size=(520, 170))  #置顶窗口        self.value = ''        self.pas=pas        # 创建副窗口的内容        panel = wx.Panel(self)        label = wx.StaticText(panel, label=text, pos=(10, 10))        but = wx.Button(panel,label='确定',pos=(200,90))        but.Bind(wx.EVT_BUTTON, self.go_fun)        close_btn = wx.Button(panel,label='取消',pos=(300,90))        close_btn.Bind(wx.EVT_BUTTON, self.close_win)        if ipdb == 'ip':            new = conf.get('set_DS', 'HOST')        elif ipdb == 'db':            dbi = conf.get('SETTINGS', 'dbid')            dbi = dbi.encode('utf-8')            new = cipher.decrypt(dbi)        else:            new = ipdb        self.pasw = wx.TextCtrl(panel, style=wx.ALIGN_CENTER|wx.TE_PROCESS_ENTER, pos=(105,60), size=(200,22))        self.pasw.Bind(wx.EVT_TEXT_ENTER,self.go_fun)        self.text = wx.TextCtrl(panel, style=wx.TE_PROCESS_ENTER, pos=(105,40), size=(200,22))        self.text.SetValue(new) #注意：该文本控件添加了 style 参数所以 Value的默认参数就不能在创建时添加了        self.text.Bind(wx.EVT_TEXT_ENTER,self.go_fun)        self.pasw.Hide()        self.text.Hide()        self.Center()   # 将副窗口放置在屏幕中间        self.IsTopLevel()        self.Show()        if showedit:            if self.pas == 'passwer':                self.pasw.Show()                self.pasw.SetFocus()            else:                self.text.Show()                self.text.SetFocus()    def close_win(self,event):        self.Close()    def go_fun(self,event):        if self.pas == 'passwer':            self.value = self.pasw.GetValue()        else:            self.value = self.text.GetValue()        self.EndModal(wx.ID_OK) #关闭子窗口    def get_input(self):        return self.value# 虚拟表格class MyGridTable(gridlib.GridTableBase):    def __init__(self, data):        super().__init__()        self.data = data    # 作为表格的数据源，它存储了表格中的所有数据，并在需要时被 MyGridTable 类使用来提供表格所需的数据。        self.col_labels = ['D', '状态', '修改时间', '     文  件  路  径  （虚拟表格）', '详情', '大小', 'MD5']  #自定义列标签名    def GetNumberRows(self):        return len(self.data)    def GetNumberCols(self):        return 7# 通过返回 len(self.data) 可以获得表格的行数，这决定了表格中有多少行数据。在 GetNumberCols 方法中，# 通过检查 self.data 中第一个内层列表的长度来获取表格的列数，从而决定了表格有多少列。    def IsEmptyCell(self, row, col):        return False# 根据传入的行和列索引，通过访问 self.data 来获取相应位置的数据。在示例中，我们假设 self.data 中的每个元素都是字符串类型，# 所以使用 str(self.data[row][col]) 将数据转换为字符串。    def GetValue(self, row, col):   #获取呈现表的数据，二进制在这里转换        value=self.data[row][col]        if isinstance(value, bytes):            value = value        return value# 将新的值赋给 self.data[row][col]，从而实现更新表格数据。    def SetValue(self, row, col, value):        self.data[row][col] = value    def SelectAll(self):        # 获取当前数据表的行数        num_rows = self.GetNumberRows()        if num_rows > 0:            # 选中所有行            for row in range(num_rows):                self.SelectRow(row)    def DeleteRows(self, pos, numRows=1):        if numRows <= 0 or pos < 0 or pos + numRows > self.GetNumberRows():            return False        # 在数据中删除指定行        del self.data[pos:pos + numRows]        # 通知表格删除行        grid = self.GetView()        if grid:            grid.ProcessTableMessage(                gridlib.GridTableMessage(                    self, gridlib.GRIDTABLE_NOTIFY_ROWS_DELETED, pos, numRows                )            )        return True#设置列标签名    def GetColLabelValue(self, col):        # 返回每列的自定义列标签        return self.col_labels[col]class MyFrame(wx.Frame):    def __init__(self, parent, title):        super(MyFrame, self).__init__(parent, title=title, size=(1616, 900))        global username, NET        # 加载图标文件并创建 wx.Icon 对象        # temp_icon_file = "temp.ico"        # with open(temp_icon_file, "wb") as f:        #     f.write(base64.b64decode(icondata.icons_data['']))        # icon = wx.Icon(temp_icon_file, wx.BITMAP_TYPE_ICO)# 设置窗口的标题栏图标        image_stream = io.BytesIO(base64.b64decode(icondata.icons_data['icon_add']))        image = wx.Image(image_stream, wx.BITMAP_TYPE_ICO)        icon = wx.Icon(wx.Bitmap(image))        self.SetIcon(icon)        self.menubar = wx.MenuBar()        self.SetMenuBar(self.menubar)        self.SelDif = True# 创建一个文件菜单        self.file_menu = wx.Menu()        id_chachong = wx.NewIdRef() # 分配自定义ID        item_chachong = wx.MenuItem(self.file_menu, id_chachong, "查找重复文件 (将替换现有数据)")  #创建子菜单成员        sear_icon_file = "temps.png"        with open(sear_icon_file, "wb") as f:            f.write(base64.b64decode(icondata.icons_data['icon_search']))        sicon = wx.Icon(sear_icon_file, wx.BITMAP_TYPE_PNG)        item_chachong.SetBitmap(sicon)  #设置子菜单图标        self.file_menu.Append(item_chachong)        id_CCtoR = wx.NewIdRef() # 分配自定义ID        self.item_CC = wx.MenuItem(self.file_menu, id_CCtoR, "将查重结果导入数据库（保留独一文件 将替换现有数据）")        with open(sear_icon_file, "wb") as f:            f.write(base64.b64decode(icondata.icons_data['icon_input']))        sicon = wx.Icon(sear_icon_file, wx.BITMAP_TYPE_PNG)        self.item_CC.SetBitmap(sicon)        self.file_menu.Append(self.item_CC)        id_delMd5Err = wx.NewIdRef() # 分配自定义ID        item_delErr = wx.MenuItem(self.file_menu, id_delMd5Err, "修复MD5异常")        with open(sear_icon_file, "wb") as f:            f.write(base64.b64decode(icondata.icons_data['icon_delmd5']))        sicon = wx.Icon(sear_icon_file, wx.BITMAP_TYPE_PNG)        item_delErr.SetBitmap(sicon)        self.file_menu.Append(item_delErr)        self.id_seldif = wx.NewIdRef() # 分配自定义ID        item_seldif = wx.MenuItem(self.file_menu, self.id_seldif, "选择所有重复行文件 (Ctrl+Alt+A)", kind=wx.ITEM_CHECK)        with open(sear_icon_file, "wb") as f:            f.write(base64.b64decode(icondata.icons_data['seldif_png']))        sicon = wx.Icon(sear_icon_file, wx.BITMAP_TYPE_PNG)        item_seldif.SetBitmap(sicon)        self.file_menu.Append(item_seldif)        id_RData = wx.NewIdRef() # 分配自定义ID        self.item_RD = wx.MenuItem(self.file_menu, id_RData, "刷新选中查重菜单存档开关: 关 (激活存档更新开关)")        with open(sear_icon_file, "wb") as f:            f.write(base64.b64decode(icondata.icons_data['RD']))        sicon = wx.Icon(sear_icon_file, wx.BITMAP_TYPE_PNG)        self.item_RD.SetBitmap(sicon)        self.file_menu.Append(self.item_RD)        id_getDif = wx.NewIdRef() # 分配自定义ID        item_getDif = wx.MenuItem(self.file_menu, id_getDif, "刷新查重菜单")        with open(sear_icon_file, "wb") as f:            f.write(base64.b64decode(icondata.icons_data['icon_ref']))        sicon = wx.Icon(sear_icon_file, wx.BITMAP_TYPE_PNG)        item_getDif.SetBitmap(sicon)        self.file_menu.Append(item_getDif)        id_delDif = wx.NewIdRef() # 分配自定义ID        item_delDif = wx.MenuItem(self.file_menu, id_delDif, "删除查重数据库")        with open(sear_icon_file, "wb") as f:            f.write(base64.b64decode(icondata.icons_data['del_dif']))        sicon = wx.Icon(sear_icon_file, wx.BITMAP_TYPE_PNG)        item_delDif.SetBitmap(sicon)        self.file_menu.Append(item_delDif)        os.remove(sear_icon_file)        self.file_menu.AppendSeparator() #分隔        # 事件处理        self.Bind(wx.EVT_MENU, self.chachong_menu, id=id_chachong)  # 注意：此顺序关系menu.Append菜单快捷键的顺序        self.Bind(wx.EVT_MENU, self.md5Error_clear, id=id_delMd5Err)        self.Bind(wx.EVT_MENU, self.ChaChongToRedis, id=id_CCtoR)        self.Bind(wx.EVT_MENU, self.sel_dif_row, id=self.id_seldif)        self.Bind(wx.EVT_MENU, self.RefleshDifData, id=id_RData)        self.Bind(wx.EVT_MENU, self.get_dif, id=id_getDif)        self.Bind(wx.EVT_MENU, self.del_dif_redis, id=id_delDif)        self.menubar.Append(self.file_menu, "■ 文件查重")        #菜单：文件        self.file_menu_2=wx.Menu()        id_setRedisId = wx.NewIdRef()  # 分配自定义ID        self.smenu_filecopy = wx.MenuItem(self.file_menu_2, id_setRedisId, "提取文件")        image_stream = io.BytesIO(base64.b64decode(icondata.icons_data['icon_save']))        image = wx.Image(image_stream, wx.BITMAP_TYPE_PNG)        self.smenu_filecopy.SetBitmap(wx.Bitmap(image))        self.file_menu_2.Append(self.smenu_filecopy)        id_openTiQu = wx.NewIdRef()  # 分配自定义ID        self.smenu_openTiQu = wx.MenuItem(self.file_menu_2, id_openTiQu, "打开提取路径")        image_stream = io.BytesIO(base64.b64decode(icondata.icons_data['icon_save']))        image = wx.Bitmap(wx.Image(image_stream, wx.BITMAP_TYPE_PNG))        self.smenu_openTiQu.SetBitmap(image)        self.file_menu_2.Append(self.smenu_openTiQu)        self.file_menu_2.AppendSeparator()  # 分隔        id_countf = wx.NewIdRef()  # 分配自定义ID        self.smenu_countf = wx.MenuItem(self.file_menu_2, id_countf, "计算列表选中数量 (结果显示在底部) (Ctrl+Alt+C)")        image_stream = io.BytesIO(base64.b64decode(icondata.icons_data['seldif_png']))        image = wx.Image(image_stream, wx.BITMAP_TYPE_PNG)        self.smenu_countf.SetBitmap(wx.Bitmap(image))        self.file_menu_2.Append(self.smenu_countf)        self.Bind(wx.EVT_MENU, self.TiQu_list, id=id_setRedisId)        self.Bind(wx.EVT_MENU, self.open_TiQu, id=id_openTiQu)        self.Bind(wx.EVT_MENU, self.Grid_sel_call, id=id_countf)        self.menubar.Append(self.file_menu_2, "□ 文件")#菜单：数据库        self.file_menu_redis=wx.Menu()        id_setRedisId = wx.NewIdRef()  # 分配自定义ID        self.sel_Redis = wx.MenuItem(self.file_menu_redis, id_setRedisId, "设置数据库 (1-15)")        image_stream = io.BytesIO(base64.b64decode(icondata.icons_data['icon_input']))        image = wx.Bitmap(wx.Image(image_stream, wx.BITMAP_TYPE_PNG))        self.sel_Redis.SetBitmap(image)        self.file_menu_redis.Append(self.sel_Redis)        id_refleshR = wx.NewIdRef()  # 分配自定义ID        self.ref_Redis = wx.MenuItem(self.file_menu_redis, id_refleshR, "刷新当前数据库内容")        image_stream = io.BytesIO(base64.b64decode(icondata.icons_data['refresh_r']))        sicon = wx.Bitmap(wx.Image(image_stream, wx.BITMAP_TYPE_PNG))        self.ref_Redis.SetBitmap(sicon)        self.file_menu_redis.Append(self.ref_Redis)        id_editST = wx.NewIdRef()  # 分配自定义ID        self.ref_editST = wx.MenuItem(self.file_menu_redis, id_editST, "修改右列表选中数据库<备注>")        image_stream = io.BytesIO(base64.b64decode(icondata.icons_data['editST']))        sicon = wx.Bitmap(wx.Image(image_stream, wx.BITMAP_TYPE_PNG))        self.ref_editST.SetBitmap(sicon)        self.file_menu_redis.Append(self.ref_editST)        id_delRedis = wx.NewIdRef()  # 分配自定义ID        self.ref_DelRedis = wx.MenuItem(self.file_menu_redis, id_delRedis, "删除右列表选中数据库")        image_stream = io.BytesIO(base64.b64decode(icondata.icons_data['del_redis']))        sicon = wx.Bitmap(wx.Image(image_stream, wx.BITMAP_TYPE_PNG))        self.ref_DelRedis.SetBitmap(sicon)        self.file_menu_redis.Append(self.ref_DelRedis)        self.file_menu_redis.AppendSeparator() #分隔        self.Bind(wx.EVT_MENU, self.set_redisdb, id=id_setRedisId)        self.Bind(wx.EVT_MENU, self.on_addbtn_rightclick, id=id_refleshR)        self.Bind(wx.EVT_MENU, self.editst_redis_rightclick, id=id_editST)        self.Bind(wx.EVT_MENU, self.del_redis_rightclick, id=id_delRedis)        # self.Bind(wx.EVT_MENU, self.on_addbtn_rightclick, id=id_refleshR)    #添加主菜单        self.menubar.Append(self.file_menu_redis, "〓 数据库")# 菜单：帮助        self.help_menu = wx.Menu()        id_help = wx.NewIdRef()  # 分配自定义ID        self.menu_help = wx.MenuItem(self.help_menu, id_help, "帮助文档")        image_stream = io.BytesIO(base64.b64decode(icondata.icons_data['help']))        sicon = wx.Bitmap(wx.Image(image_stream, wx.BITMAP_TYPE_PNG))        self.menu_help.SetBitmap(sicon)        self.help_menu.Append(self.menu_help)        self.help_menu.AppendSeparator() #分隔        id_update = wx.NewIdRef()  # 分配自定义ID        self.menu_update = wx.MenuItem(self.help_menu, id_update, "更新")        image_stream = io.BytesIO(base64.b64decode(icondata.icons_data['update']))        sicon = wx.Bitmap(wx.Image(image_stream, wx.BITMAP_TYPE_PNG))        self.menu_update.SetBitmap(sicon)        self.help_menu.Append(self.menu_update)        id_Rupdate = wx.NewIdRef()  # 分配自定义ID        self.menu_Rupdate = wx.MenuItem(self.help_menu, id_Rupdate, "重更新")        image_stream = io.BytesIO(base64.b64decode(icondata.icons_data['update2']))        sicon = wx.Bitmap(wx.Image(image_stream, wx.BITMAP_TYPE_PNG))        self.menu_Rupdate.SetBitmap(sicon)        self.help_menu.Append(self.menu_Rupdate)        self.Bind(wx.EVT_MENU, self.update, id=id_update)        self.Bind(wx.EVT_MENU, self.Rupdate, id=id_Rupdate)        self.Bind(wx.EVT_MENU, self.HelpFun, id=id_help)        self.menubar.Append(self.help_menu, "? 帮助")#★启动时获取菜单信息需要链接数据库        self.Bind(wx.EVT_MENU_OPEN, self.on_menu_open)#控件主面板        self.panel = wx.Panel(self)#平行布局：self.h_sizer（用于放置顶部的按钮与下拉列表）        self.h_sizer = wx.BoxSizer(wx.HORIZONTAL)#主垂直布局：self.sizer        self.sizer = wx.BoxSizer(wx.VERTICAL)# 虚拟表格切换        if conf.has_option('set_DS', 'virsual_chk'):            vchk = eval(conf.get('set_DS', 'virsual_chk'))        else:            vchk = False        self.v_chk = wx.CheckBox(self.panel)        self.v_chk.SetToolTip('勾选切换到虚拟表格（提高载入速度）')        self.v_chk.SetValue(vchk)        # self.search_fol_chk.SetValue(True)        self.v_chk.Bind(wx.EVT_CHECKBOX, self.VirtualGridChk)        self.h_sizer.Add(self.v_chk, flag=wx.ALIGN_CENTER | wx.LEFT, border=2)# Button导入数据库按钮：inputData_btn        self.inputData_btn = wx.Button(self.panel, wx.ID_ANY, size=(38, 28))        image_stream = io.BytesIO(base64.b64decode(icondata.icons_data['icon_input']))        image = wx.Image(image_stream, wx.BITMAP_TYPE_PNG)        self.inputData_btn.SetBitmap(wx.Bitmap(image))        self.inputData_btn.SetToolTip('将主路径全新导入数据库，原数据会清除')        self.inputData_btn.Bind(wx.EVT_BUTTON, self.posswer)        self.h_sizer.Add(self.inputData_btn, flag=wx.ALL, border=2)        self.inputData_btn.Enable(False)# Button获取复制文件添加数据库按钮：copyfile_btn        copyfile_btn = wx.Button(self.panel, wx.ID_ANY, size=(38, 28))        image_stream = io.BytesIO(base64.b64decode(icondata.icons_data['icon_ds']))        image = wx.Image(image_stream, wx.BITMAP_TYPE_ICO)        copyfile_btn.SetBitmap(wx.Bitmap(image))        copyfile_btn.SetToolTip('获取待拷贝文件（右键双击刷新当前数据库内容）')        copyfile_btn.Bind(wx.EVT_BUTTON, self.copy_adddata)        copyfile_btn.Bind(wx.EVT_RIGHT_DCLICK, self.on_addbtn_rightclick)        self.h_sizer.Add(copyfile_btn, flag=wx.ALL, border=2)# Button复制文件添加数据库执行按钮：cpy_btn        self.cpy_btn = wx.Button(self.panel, wx.ID_ANY, size=(38, 28))        self.cpy_btn.SetToolTip('导入文件并更新数据库')        self.cpy_btn.SetBitmap(icon)        self.cpy_btn.Bind(wx.EVT_BUTTON, self.click_cpybtn)        self.cpy_btn.Hide()        self.h_sizer.Add(self.cpy_btn, flag=wx.ALL, border=2)#CheckBox遍历文件选项：search_fol        self.search_fol_chk = wx.CheckBox(self.panel)        self.search_fol_chk.SetToolTip('勾选对当前路径进行数据预处理')        # self.search_fol_chk.SetValue(True)        self.search_fol_chk.Bind(wx.EVT_CHECKBOX, self.check_extfilter)        self.h_sizer.Add(self.search_fol_chk, flag=wx.ALIGN_CENTER|wx.LEFT, border=2)#ComboBox路径下拉列表：path_combox        pco=0        try:            pco = int(conf.get('set_DS', 'path_count'))        except: pass        current_values = []        if pco > 0:            for i in range(pco):                if conf.has_option('PATH_DS', str(i)):                    pp = conf.get('PATH_DS', str(i))                    if os.path.exists(pp):                        current_values.append(pp)        self.path_combox = wx.ComboBox(self.panel, wx.ID_ANY, choices=current_values, size=(-1, 20), style=wx.TE_PROCESS_ENTER) # size=设置宽度 -1为默认高度        self.path_combox.Bind(wx.EVT_COMBOBOX, self.on_comb_return)        self.path_combox.Bind(wx.EVT_TEXT_ENTER, self.on_comb_return)        # self.path_combox.SetMaxSize((548, -1))        # self.combox.Bind(wx.EVT_COMBOBOX_DROPDOWN, self.on_comb_return) #这里使用打开下拉列表事件替代文本修改，避免函数死循环        try:            self.path_combox.SetValue(conf.get('PATH_DS', 'current'))        except:            self.path_combox.SetValue(os.getcwd())        self.h_sizer.Add(self.path_combox, proportion=1, flag=wx.EXPAND | wx.TOP | wx.RIGHT | wx.BOTTOM, border=4)#ComboBox文件、文件夹：comb_types        self.comb_tiqu = wx.ComboBox(self.panel, wx.ID_ANY, choices=current_values, size=(-1, 20), style=wx.TE_PROCESS_ENTER)    #, style=wx.CB_READONLY        self.comb_tiqu.SetToolTip('选择提取文件保存的路径')        self.comb_tiqu.SetBackgroundColour(wx.Colour(255, 240, 190))        self.comb_tiqu.Bind(wx.EVT_COMBOBOX, self.on_comb2_return)        self.comb_tiqu.Bind(wx.EVT_TEXT_ENTER, self.on_comb2_return)        self.comb_tiqu.SetMaxSize((548, -1))        try:            self.comb_tiqu.SetValue(conf.get('PATH_DS', 'current2'))        except:            self.comb_tiqu.SetValue(os.getcwd())        self.h_sizer.Add(self.comb_tiqu, proportion=1, flag=wx.EXPAND | wx.TOP | wx.RIGHT | wx.BOTTOM, border=4)#指定自动选择文件大小M        if conf.has_option('set_DS', 'Sel_Size_Save'):            S_S = conf.get('set_DS', 'Sel_Size_Save')        else:            S_S = '0'        self.sel_size = wx.TextCtrl(self.panel, style=wx.TE_RIGHT, size=(45,22))   #文本居中：style=wx.TE_CENTER        self.sel_size.SetToolTip('设置Ctrl+Shift+Alt+A自动选择指定大小文件，输入整数单位M')        self.sel_size.SetValue(S_S)        self.sel_size.SetBackgroundColour(wx.Colour(225, 225, 226))        self.sel_size.Bind(wx.EVT_TEXT, self.Sel_Size_Save)        self.h_sizer.Add(self.sel_size, flag=wx.EXPAND|wx.TOP|wx.BOTTOM, border=4)        Mtext=wx.StaticText(self.panel, label='M', style=wx.ST_NO_AUTORESIZE)        self.h_sizer.Add(Mtext, flag=wx.ALIGN_CENTER_VERTICAL)#ComboBox搜索内容历史列表：combox_S        pcos=0        if conf.has_option('set_DS_t', 'path_count'):            pcos = int(conf.get('set_DS_t', 'path_count'))        t_currents_values = []        if pcos > 0:            for i in range(pcos):                if conf.has_option('search_text', str(i)):                    pp = conf.get('search_text', str(i))                    t_currents_values.append(pp)        self.combox_S = wx.ComboBox(self.panel, wx.ID_ANY, choices=t_currents_values,style=wx.TE_PROCESS_ENTER) #size设置宽度 -1为默认高度        self.combox_S.SetToolTip('搜索关键字（在导入时也作为过滤导入 或 标签的备注）\n起始搜索点击右边【搜索】按钮\n再使用*替代符(按回车)检索搜索到的内容')        self.combox_S.Bind(wx.EVT_COMBOBOX, self.on_comb_sel)        self.combox_S.Bind(wx.EVT_TEXT_ENTER, self.search_Enter)        self.combox_S.SetMinSize((100,-1))        self.combox_S.SetMaxSize((200,-1))        # self.combox_S.SetMinSize((180,-1))        try:            self.combox_S.SetValue(conf.get('search_text','current'))        except:            pass        self.h_sizer.Add(self.combox_S, proportion=1, flag=wx.EXPAND|wx.TOP|wx.LEFT|wx.RIGHT|wx.BOTTOM, border=4)        # self.edits_comb = ['<All>']#ComboBox修改方式选择：comb_users        # self.comb_users = wx.ComboBox(self.panel, wx.ID_ANY, value='<All>', choices=['<All>'])        # self.comb_users.SetToolTip('过滤：作者')        # self.comb_users.SetBackgroundColour(wx.Colour(225, 250, 240))        # self.comb_users.Bind(wx.EVT_COMBOBOX, self.filter_search)        # self.h_sizer.Add(self.comb_users,proportion=1, flag=wx.TOP|wx.RIGHT|wx.BOTTOM, border=4)        # self.users_comb = ['<All>']    #布局：平行布局放入主布局最顶部        self.sizer.Add(self.h_sizer, 0, wx.EXPAND|wx.ALL, 1)  # 里面的参数同上（占比，标签，边界），参数名如果不写需要统一都不写#Button按钮：button_save        # 加载图标文件并创建 wx.Bitmap 对象        image_stream = io.BytesIO(base64.b64decode(icondata.icons_data['all']))        sicon = wx.Bitmap(wx.Image(image_stream, wx.BITMAP_TYPE_PNG))#Button，显示所有文件Grid        button_all = wx.Button(self.panel, wx.ID_ANY, size=(28, 28))        button_all.SetBitmap(sicon)        button_all.SetToolTip('显示所有文件')        # 绑定按钮事件        button_all.Bind(wx.EVT_BUTTON, self.show_all_Grid)        self.h_sizer.Add(button_all, flag=wx.ALIGN_CENTER|wx.RIGHT, border=3)# 创建 wx.Button，设置图标和标签        image_stream = io.BytesIO(base64.b64decode(icondata.icons_data['icon_save']))        sicon = wx.Bitmap(wx.Image(image_stream, wx.BITMAP_TYPE_PNG))        button_save = wx.Button(self.panel, wx.ID_ANY, size=(28, 28))        button_save.SetBitmap(sicon)        button_save.SetToolTip('创建本地数据存档 (右键双击取消列表2选择，用于不修改数据库删除文件)')        # 绑定按钮事件        button_save.Bind(wx.EVT_BUTTON, self.save_LocalData)        button_save.Bind(wx.EVT_RIGHT_DCLICK, self.List2_Deselect)        # button_save.Bind(wx.EVT_RIGHT_DCLICK, self.del_MemData)        self.h_sizer.Add(button_save, flag=wx.ALIGN_CENTER|wx.RIGHT, border=3)#Button按钮：button_del        # 加载图标文件并创建 wx.Bitmap 对象        image_stream = io.BytesIO(base64.b64decode(icondata.icons_data['icon_del']))        sicon = wx.Bitmap(wx.Image(image_stream, wx.BITMAP_TYPE_PNG))        # 创建 wx.Button，设置图标和标签        button_del = wx.Button(self.panel, wx.ID_ANY, size=(28, 28))        button_del.SetBitmap(sicon)        button_del.SetToolTip('删除本地存档（双击右键删除缓存）')        # 绑定按钮事件        button_del.Bind(wx.EVT_BUTTON, self.del_LocalData)        button_del.Bind(wx.EVT_RIGHT_DCLICK, self.del_MemData)        self.h_sizer.Add(button_del, flag=wx.ALIGN_CENTER|wx.RIGHT, border=3)#Button按钮：button        # 加载图标文件并创建 wx.Bitmap 对象        # icon = wx.Bitmap(temp_icon_file2, wx.BITMAP_TYPE_ICO)    #使用ico类型图标        # os.remove(temp_icon_file2)        # 创建 wx.Button，设置图标和标签        button = wx.Button(self.panel, wx.ID_ANY, label="搜索", size=(80, 28))        button.SetBitmap(icon)        button.SetToolTip('右键双击清空搜索历史')        # 绑定按钮事件        button.Bind(wx.EVT_BUTTON, self.search_Button)        button.Bind(wx.EVT_RIGHT_DCLICK, self.DelSTHis)    #布局：按钮放入顶部平行布局        self.h_sizer.Add(button, flag=wx.ALIGN_CENTER|wx.RIGHT, border=3)#水平布局：放置两个列表        self.h_sizer_list = wx.BoxSizer(wx.HORIZONTAL)#列表与类型过滤文本的垂直布局        self.v_sizer = wx.BoxSizer(wx.VERTICAL)#BoxSizer过滤文本和相关按钮的平行布局：ext_sizer        self.ext_sizer = wx.BoxSizer(wx.HORIZONTAL)    # 侧边按垂直布局        self.btn_sizer = wx.BoxSizer(wx.VERTICAL)    # 获取所有文件类型        self.ext_getall_btn = wx.Button(self.panel, id=wx.ID_ANY, label='获', size=(30, 28))        self.ext_getall_btn.SetBackgroundColour(wx.Colour(250,110,90))        self.ext_getall_btn.Bind(wx.EVT_BUTTON,self.get_allext)        self.ext_getall_btn.SetToolTip('获取所有文件类型')        self.btn_sizer.Add(self.ext_getall_btn,0,wx.TOP,0)        self.ext_getall_btn.Hide()    # 保存排除类型按钮        self.ext_saveext_btn=wx.Button(self.panel, id=wx.ID_ANY, label='存', size=(30, 28))        self.ext_saveext_btn.SetBackgroundColour(wx.Colour(230,210,90))        self.ext_saveext_btn.Bind(wx.EVT_BUTTON, self.on_extfilter_saver)        self.ext_saveext_btn.SetToolTip('保存当前过滤文件类型 (Enter)')        self.btn_sizer.Add(self.ext_saveext_btn,0,wx.TOP,3)        self.ext_saveext_btn.Hide()    # 读取远程设置        self.ext_read_btn = wx.Button(self.panel, id=wx.ID_ANY, label='读', size=(30, 28))        self.ext_read_btn.SetBackgroundColour(wx.Colour(130,250,190))        self.ext_read_btn.Bind(wx.EVT_BUTTON,self.get_server_set)        self.ext_read_btn.SetToolTip('读取保存设置')        self.btn_sizer.Add(self.ext_read_btn,0,wx.TOP,3)        self.ext_read_btn.Hide()    # 读取全部文件类型        self.ext_readall_btn = wx.Button(self.panel, id=wx.ID_ANY, label='全', size=(30, 28))        self.ext_readall_btn.SetBackgroundColour(wx.Colour(110,240,160))        self.ext_readall_btn.Bind(wx.EVT_BUTTON,self.get_server_set_all)        self.ext_readall_btn.SetToolTip('读取全部文件类型')        self.btn_sizer.Add(self.ext_readall_btn,0,wx.TOP,3)        self.ext_readall_btn.Hide()        self.ext_sizer.Add(self.btn_sizer,0,wx.CENTER,1)    # TextCtrl检索路径文件过滤：ext_filter        extstring = ''        pp = self.getNoSlashPath(self.path_combox.GetValue())        if conf.has_option('set_DS', f'EXTFILTER_{pp}_{username}'):            extstring = conf.get('set_DS', f'EXTFILTER_{pp}_{username}')        self.ext_filter = wx.TextCtrl(self.panel, value=extstring, style=wx.TE_PROCESS_ENTER|wx.TE_MULTILINE)        # self.ext_filter.SetToolTip('输入检索预处理文件的排除类型，用;(分号)隔开')        self.ext_filter.SetBackgroundColour(wx.Colour(242, 246, 240))        self.ext_filter.SetForegroundColour(wx.Colour(137, 146, 80))        font = wx.Font(12, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD)        self.ext_filter.SetFont(font)        self.ext_filter.Bind(wx.EVT_TEXT_ENTER, self.on_extfilter_saver)        self.ext_sizer.Add(self.ext_filter,2,wx.EXPAND,1)        self.ext_filter.Hide()    # 目录排除文本        folstring = ''        if conf.has_option('set_DS', f'FOLFILTER_{pp}_{username}'):            folstring = conf.get('set_DS', f'FOLFILTER_{pp}_{username}')        self.fol_filter = wx.TextCtrl(self.panel, value=folstring, style=wx.TE_PROCESS_ENTER|wx.TE_MULTILINE)        self.fol_filter.SetToolTip('输入排除文件夹，用;(分号)隔开')        self.fol_filter.SetBackgroundColour(wx.Colour(242, 240, 230))        self.fol_filter.SetForegroundColour(wx.Colour(157, 126, 80))        self.fol_filter.SetFont(font)        self.fol_filter.Bind(wx.EVT_TEXT_ENTER, self.on_folfilter_saver)        self.ext_sizer.Add(self.fol_filter,1,wx.EXPAND,1)        self.fol_filter.Hide()#ListBox多选列表：list        self.list = wx.ListBox(self.panel, style=wx.VSCROLL|wx.LB_EXTENDED)        self.list.Bind(wx.EVT_LEFT_DCLICK, self.on_list_doubleclick)        self.v_sizer.Add(self.list, proportion=1, flag=wx.EXPAND, border=4)        self.h_sizer_list.Add(self.v_sizer, proportion=1, flag=wx.EXPAND|wx.LEFT, border=4)#ListBox多选列表：list_2        self.list_2 = wx.ListBox(self.panel, style=wx.VSCROLL|wx.LB_EXTENDED)        self.list_2.Bind(wx.EVT_LISTBOX, self.on_list2_sel)        self.list_2.SetBackgroundColour(wx.Colour(237, 236, 255))        self.h_sizer_list.Add(self.list_2, proportion=1, flag=wx.EXPAND|wx.LEFT|wx.RIGHT, border=4)        self.sizer.Add(self.h_sizer_list, proportion=1, flag=wx.EXPAND|wx.ALL, border=2)#中间信息显示文本：msg_txt        self.msg_txt = wx.StaticText(self.panel,label=NormalTex)        self.msg_txt.SetForegroundColour(wx.Colour(96,157,120))        self.sizer.Add(self.msg_txt, proportion=0, flag=wx.LEFT, border=12)#grid_out表格控件：grid.Grid        # self.text_out = wx.TextCtrl(self.panel, style=wx.TE_MULTILINE|wx.VSCROLL|wx.TE_READONLY|wx.TE_DONTWRAP) #wx.TE_MULTILINE|wx.TE_READONLY（多行只读）        # self.text_out.SetBackgroundColour(wx.Colour(17, 16, 20))        # self.text_out.SetForegroundColour(wx.Colour(113, 216, 130))        self.grid_out = wx.grid.Grid(self.panel)        self.grid_out.CreateGrid(0,7)        # self.grid_out.SetRowSize(0,28)  #设置第一行高度        self.grid_out.SetColLabelValue(2, '修改时间')        self.grid_out.SetColLabelValue(3, '文  件  路  径')        self.grid_out.SetColLabelValue(4, '详情')        self.grid_out.SetColLabelValue(5, '大小')        self.grid_out.SetColLabelValue(0, 'D')        self.grid_out.SetColLabelValue(1, '状态')        self.grid_out.SetColLabelValue(6, 'MD5')        self.grid_out.AutoSizeColumns()        self.grid_out.SetSelectionBackground(wx.Colour(202, 100, 127))  #设置选中背景色        # self.Bind(wx.EVT_CHAR_HOOK,self.on_char_hook)        # self.grid_out.Bind(wx.grid.EVT_GRID_RANGE_SELECT,self.Grid_sel_call)    #绑定Grid行选中事件（EVT_GRID_RANGE_SELECT不会循环选择）        self.grid_out.EnableEditing(False)  #锁定表格编辑        self.sizer.Add(self.grid_out, proportion=3, flag=wx.EXPAND|wx.ALL, border=5) #proportion比例为整数，该件比上面占面积大2倍        # self.grid_out.Hide()# 虚拟表格：grid_out_v        self.grid_out_v = gridlib.Grid(self.panel)        self.grid_out_v.CreateGrid(0, 7)    # 只能创建一次        self.grid_out_v.SetColLabelValue(2, '修改时间')        self.grid_out_v.SetColLabelValue(3, '文  件  路  径  （虚拟表格）')        self.grid_out_v.SetColLabelValue(4, '详情')        self.grid_out_v.SetColLabelValue(5, '大小')        self.grid_out_v.SetColLabelValue(0, 'D')        self.grid_out_v.SetColLabelValue(1, '状态')        self.grid_out_v.SetColLabelValue(6, 'MD5')        self.grid_out_v.AutoSizeColumns()        self.grid_out_v.SetSelectionBackground(wx.Colour(202, 100, 127))  #设置选中背景色        self.grid_out_v.SetDefaultCellBackgroundColour(wx.Colour(232, 250, 237))  #设置背景色        self.grid_out_v.EnableEditing(False)  #锁定表格编辑        self.sizer.Add(self.grid_out_v, proportion=3, flag=wx.EXPAND|wx.ALL, border=5) #proportion比例为整数，该件比上面占面积大2倍    #平行布局2        self.h_sizer_2 = wx.BoxSizer(wx.HORIZONTAL)#StaticText操作状态显示文本：text_label        self.text_label = wx.StaticText(self.panel, label=':', style=wx.FONTWEIGHT_BOLD|wx.ST_NO_AUTORESIZE, size=(180,-1))        self.text_label.SetForegroundColour(wx.Colour(6, 126, 37))        # self.text_label.SetBackgroundColour(wx.Colour(6, 176, 37))        self.h_sizer_2.Add(self.text_label, proportion=0, flag=wx.RIGHT, border=4)#Gauge进度条：progress_bar        self.progress_bar = wx.Gauge(self.panel, range=100)        self.h_sizer_2.Add(self.progress_bar, proportion=1, flag=wx.EXPAND|wx.RIGHT, border=3)        self.sizer.Add(self.h_sizer_2, 0, wx.EXPAND|wx.ALL, 1)#显示查询变量内存占用        self.member_use = wx.StaticText(self.panel)        self.member_use.SetToolTip('[搜索缓存数 : 占用内存]')        self.h_sizer_2.Add(self.member_use, proportion=0, flag=wx.RIGHT, border=3)#StaticTextIP显示静态文本：ipshow        self.ipshow = wx.StaticText(self.panel, label=f'{s_host}:{DBSET}')        self.ipshow.Bind(wx.EVT_RIGHT_UP, self.edit_ip)        self.h_sizer_2.Add(self.ipshow, proportion=0, flag=wx.RIGHT, border=8)        self.h_size_3 = wx.BoxSizer(wx.HORIZONTAL)        self.sizer.Add(self.h_size_3, 0, wx.EXPAND|wx.ALL, 1)#底部信息显示        self.text_label2 = wx.StaticText(self.panel, label='', style=wx.ST_NO_AUTORESIZE)   #添加自动换行style，避免快速刷新文本被裁切        self.h_size_3.Add(self.text_label2, proportion=1, flag=wx.ALIGN_LEFT|wx.LEFT, border=6)        self.text_label2.SetForegroundColour(wx.Colour(117, 116, 110))        self.panel.SetSizer(self.sizer)        self.Bind(wx.EVT_CHAR_HOOK,self.on_char_hook)   #绑定快捷键#移动主窗口位置        self.Bind(wx.EVT_CLOSE,self.OnClose)        if conf.has_option('set_DS','pos'):            pos = eval(conf.get('set_DS','pos'))        else:            pos = (400,400)        self.Move(pos)# 初始化时调用：        self.r = None   #变量预赋予空值，以便在可以正常链接数据库时赋予        self.setr = None        self.FindTxt()        self.StartStop = True        self.RefleshDifJson = True        # self.check_extfilter(self)        self.VirtualGridChk(self)   #刷新虚拟表格选项        # ret = os.system('ping 192.168.10.38 -n 1')  # ip前面不用加斜杠        # if ret == 0:        if self.check_redis(s_host,'',sdb=DBSET):            self.get_Data_list()            self.get_server_set(self)            self.get_Dif_menu(self)            self.get_Redis_menu(self)            # self.update(self)            # FirstUp = True        else:            NET = False                        # subprocess.Popen(["explorer.exe", "\\\\192.168.10.38\\点睛工作室\\Softs\\DUPCLICKER"], shell=True)                        # subprocess.Popen(["explorer.exe", os.getcwd()], shell=True)                        # self.Close()    def OnClose(self, event):        # 记录窗口位置        pos = self.GetPosition()        conf.set('set_DS','pos',f"{pos.x},{pos.y}")        conf.write(open(setPath, 'w+', encoding="utf-8"))        self.Destroy()    def List2_Deselect(self,event):        num_selected = self.list_2.GetSelections()        # 逐个取消选择选中的项        for index in num_selected:            self.list_2.Deselect(index)    def HelpFun(self,event):        os.startfile('https://idreamsky.feishu.cn/docx/UiyldDR2MopIphx5sQacyTT9nSg')    def Rupdate(self,event):        dlg = wx.MessageDialog(self, "确定要重新下载最新版本？", "[更新]", wx.YES_NO | wx.YES_DEFAULT | wx.ICON_INFORMATION)        result = dlg.ShowModal()        dlg.Destroy()        if result == wx.ID_YES:            os.system(r'start ' + os.getcwd() + '/DCupdate.bat')    def update(self,event):        if NET:            if self.setr.exists('version'):                global FirstUp                vv = int(self.setr.get('version'))                if vv > vvv:                    dlg = wx.MessageDialog(self, "有新版本，是否立即更新？", "[更新]", wx.YES_NO | wx.YES_DEFAULT | wx.ICON_INFORMATION)                    result = dlg.ShowModal()                    dlg.Destroy()                    if result == wx.ID_YES:                        os.system(r'start ' + os.getcwd() + '/DCupdate.bat')                        # try:                            # copyfile('\\\\192.168.10.38\\点睛工作室\\Softs\\BKF\\update.bat', os.getcwd() + '/update.bat')                        # except:                        #     dlg = wx.MessageDialog(self, "检查网络或项目根目录是否有 DCupdate.bat", "[更新]", wx.OK | wx.ICON_INFORMATION)                        #     dlg.ShowModal()                        #     dlg.Destroy()                else:                    if FirstUp:                        dlg = wx.MessageDialog(self, "☆ 已经是最新版本。", "[更新]", wx.ICON_QUESTION)                        dlg.ShowModal()                        dlg.Destroy()                FirstUp = True            else:                self.setr.set('version', f'{vvv}')    def fuzzy_search(self, pattern, text):        # 如果不带’*‘则使用传统搜索        if '*' not in pattern:            return pattern in text        # 将通配符模式转换为正则表达式        pattern = pattern.replace('.', r'\.').replace('*', '.*')        pattern = f"^{pattern}$"        return bool(re.match(pattern, text))    menuSel = ''    #记录菜单选中的路径名#修复md5异常 获取md5Err: 错误文件列表    def md5Error_clear(self,event):        dlg = wx.MessageDialog(self, f'{self.menuSel}\n确定开始修复当前选择的查重列表MD5异常吗？', '修复MD5异常', wx.YES_NO | wx.ICON_QUESTION)        result = dlg.ShowModal()        dlg.Destroy()        if result == wx.ID_YES:            if NET:                FistDo=True                selected_indices = self.list_2.GetSelections()                if selected_indices != wx.NOT_FOUND:                    data=self.list_2.GetString(selected_indices[0]).split(' → ')[0]                    countSet = data.split('_')[1]                    md5errC = self.getNoSlashPath(countSet)                    if self.setr.hexists('SETTINGS', f'{md5errC}_MD5COUNT'):                        md5s = int(self.setr.hget('SETTINGS', f'{md5errC}_MD5COUNT'))                        if self.r.exists(data):                            gnum = self.grid_out.GetNumberRows()                            if gnum > 0:                                self.grid_out.DeleteRows(0, gnum)                            row=0                            if md5s>0:                                for i in range(1, md5s+1):                                    rr=self.r.hget(data, f'MD5异常:{i}')                                    ppp=eval(rr.decode('utf-8'))                                    md5 = self.calculate_md5(ppp[1])                                    if 'MD5异常' not in md5:                                        if not self.r.hexists(data, md5):                                            self.r.hset(data, md5, str(ppp))                                            md5s-=1                                            self.grid_out.AppendRows()                                            self.grid_out.SetCellValue(row, 2, '已修复')                                            self.grid_out.SetCellValue(row, 3, ppp[1])                                            self.grid_out.SetCellValue(row, 6, md5)                                            row+=1                                            if FistDo:                                                self.ResetWinSize(row)                                                FistDo = False                                        else:                                            self.r.hdel(data, f'MD5异常:{i}')                                            md5s-=1                                            self.text_label2.SetLabel(f'{ppp[1]}（已存在）')                                self.setr.hset('SETTINGS', f'{md5errC}_MD5COUNT', str(md5s))                            else:                                self.text_label2.SetLabel(f'( {data} ) 没有找到MD5异常')                    else:                        self.text_label2.SetLabel(f'( {data} ) 没有找到MD5异常')            else:                dlg = wx.MessageDialog(self, "检查数据库服务器链接", "修复MD5异常",wx.OK|wx.ICON_QUESTION)                dlg.ShowModal()                dlg.Destroy()# 设置数据库db    def set_redisdb(self,event):        db_id = self.r.connection_pool.connection_kwargs.get('db')  # 获取当前数据库ID        newdb = db_id        while newdb == db_id:   # 循环判断直到用户输入的数据库ID不等于当前ID            second_frame = MySecondaryDialog(self, '设置数据库', '输入新数据库ID:（1-15）', True, 'text', ipdb='db')            second_frame.ShowModal()  # 显示副窗口            value = second_frame.get_input()            if value!='':                newdb = int(value)            else:                return        global DBSET, ALLDB        if 15 >= newdb > 0:            if newdb not in ALLDB:  #新增数据库设置密码                second_frame = MySecondaryDialog(self, '设置数据库', '设置新数据库密码：', True, 'passwer')                second_frame.Show()  # 显示副窗口                if second_frame.ShowModal() == wx.ID_OK:  # 锁定主窗口                    newpas = second_frame.get_input()                    self.setr.hset('PAS', value, newpas)                    self.setr.hset('PAS_N', value, username)                    DBSET = newdb                    self.text_label2.SetLabel(f'数据库：{DBSET}')                    if self.check_redis(s_host, '', sdb=DBSET):                        self.ipshow.SetLabel(f'{s_host}:{DBSET}')                        self.get_Data_list()                        self.cpy_btn.Hide()                        self.ResetWinSize(0)                        self.get_dif(self)                        encrypted = cipher.encrypt(value.encode('utf-8'))                        conf.set('SETTINGS', 'dbid', str(encrypted.decode('utf-8')))                        conf.write(open(setPath, 'w+', encoding="utf-8"))                    ALLDB.append(newdb)            else:                if self.setr.hexists('PAS_N', value):                    pnam = self.setr.hget('PAS_N', value)                    if isinstance(pnam, bytes):  # 判断是否二进制                        pnam = pnam.decode('utf-8')                else:                    pnam = '管理员'                second_frame = MySecondaryDialog(self, '设置数据库', f'输入 ({pnam}) 密码：', True, 'passwer')                second_frame.Show()  # 显示副窗口                if second_frame.ShowModal() == wx.ID_OK:  # 锁定主窗口                    p_value = second_frame.get_input()                    pas = 'nopasswer'                    if self.setr.hexists('PAS', value):                        pas = self.setr.hget('PAS', value)                        if isinstance(pas, bytes):  # 判断是否二进制                            pas = pas.decode('utf-8')                    if p_value == 'zyhp' or p_value == pas:                        DBSET = newdb                        self.text_label2.SetLabel(f'数据库：{DBSET}')                        self.ipshow.SetLabel(f'{s_host}:{DBSET}')                        if self.check_redis(s_host, '', sdb=DBSET):                            self.get_Data_list()                            self.cpy_btn.Hide()                            self.ResetWinSize(0)                            self.get_dif(self)                        encrypted = cipher.encrypt(value.encode('utf-8'))                        conf.set('SETTINGS', 'dbid', str(encrypted.decode('utf-8')))                        conf.write(open(setPath, 'w+', encoding="utf-8"))                        self.get_Redis_menu(self)                    else:                        self.text_label.SetLabel('<密码错误>')        else:            dlg = wx.MessageDialog(self, f'数据库只能输入1到15之间的数！', "[设置数据库]", wx.OK | wx.ICON_WARNING)            dlg.ShowModal()    def open_TiQu(self,event):        os.startfile(self.comb_tiqu.GetValue())    def TiQu_list(self,event):        path = self.comb_tiqu.GetValue()        if os.path.exists(path):            if self.grid_out.IsShown():                selected_rows = self.grid_out.GetSelectedRows()            else:                selected_rows = self.grid_out_v.GetSelectedRows()            if selected_rows:                dlg = wx.MessageDialog(self, f'{path}\n确定开始提取文件到输出路径？ (注意：路径中如有重复文件将会被替换)', '文件提取',                                       wx.YES_NO | wx.ICON_QUESTION)                result = dlg.ShowModal()                dlg.Destroy()                if result == wx.ID_YES:                    ccc = 0                    for L in selected_rows:                        if self.grid_out.IsShown():                            selected_cells = self.grid_out.GetCellValue(selected_rows[ccc], 3)                        else:                            selected_cells = self.grid_out_v.GetCellValue(selected_rows[ccc], 3)                        ccc += 1                        if selected_cells:                            if os.path.exists(selected_cells):                                c_p = f'{path}\\{os.path.basename(selected_cells)}'                                # subprocess.run(['copy', selected_cells, c_p], shell=True)                                shutil.copy(selected_cells, c_p)                    if ccc > 0:                        dlg = wx.MessageDialog(self, f"共提取 {ccc} 个文件", "文件提取", wx.ICON_QUESTION)                        dlg.ShowModal()                        dlg.Destroy()            else:                dlg = wx.MessageDialog(self, "请在表格中选择要提取的文件", "文件提取", wx.ICON_QUESTION)                dlg.ShowModal()                dlg.Destroy()        else:            dlg = wx.MessageDialog(self, "您输入的提取路径不存在，请输入有效路径", "文件提取", wx.ICON_QUESTION)            dlg.ShowModal()            dlg.Destroy()    file_hash_dict = defaultdict(list)    def chachong_menu(self,event):  #查重        if self.check_redis(s_host, '',sdb=DBSET):            path = self.path_combox.GetValue()            dlg = wx.MessageDialog(self, f'{path}\n确定开始查找该路径重复文件操作？ (注意：原数据库将会被替换)', '查重', wx.YES_NO | wx.ICON_QUESTION)            result = dlg.ShowModal()            dlg.Destroy()            if result == wx.ID_YES:                if os.path.exists(path):                    FistDo=True                    self.file_hash_dict.clear()                    self.ChaChong_to_Redis.clear()                    #进度条 获取处理文件数（在获取所有文件类型时计算并记录）                    acsn = self.getNoSlashPath(path)                    ac = 10000                    if self.setr.hexists('SETTINGS', acsn):                        ac = int(self.setr.hget('SETTINGS', acsn))                    else:                        if conf.has_option('PATH_DS', acsn):                            ac = int(conf.get('PATH_DS', acsn))                    self.progress_bar.SetRange(ac)                    # 删除表格所有行↓                    gnum = self.grid_out.GetNumberRows()                    if gnum > 0:                        self.grid_out.DeleteRows(0, gnum)                    self.text_label.SetLabel('正在获取文件...')                    cc = 0                    if self.setr.hexists('SETTINGS', f'{acsn}_MD5COUNT'):                        self.setr.hset('SETTINGS', f'{acsn}_MD5COUNT', '0')  #重置                    keyN = f'dif_{path}'                    self.r.delete(keyN)                    for root, dirs, files in os.walk(path):                        for file_name in files:                            if self.StartStop:                                cc += 1                                self.progress_bar.SetValue(cc)                                file_path = os.path.join(root, file_name)   #完整文件路径                                f_subPath = file_path[len(path):]                                if self.ignoreFolder(f_subPath): continue  # 目录排除                                fl, ex = os.path.splitext(file_name)                                if self.ignoreFile(self.ext_filter.GetValue(), ex): continue  # 类型排除        # 查重筛选文件                                self.text_label2.SetLabel(f'正在读取：{file_path}')                                md5=self.calculate_md5(file_path)                                if self.setr.hexists('SETTINGS', f'{acsn}_MD5COUNT'):                                    mdc = int(self.setr.hget('SETTINGS', f'{acsn}_MD5COUNT'))                                else:                                    mdc = 0                                if 'MD5异常' in md5:                                    siz = self.Sizeofsize(os.path.getsize(file_path))                                    self.r.hset(keyN, f'MD5异常:{mdc}', str([file_path,siz]))                                else:                                    self.file_hash_dict[md5].append(file_path)                                self.text_label.SetLabel(f'{cc}> 异常:{mdc}')                                #刷新UI                                if cc % 64 == 0:                                    wx.Yield()                                    if cc > ac:                                        ac += 10000                                        self.progress_bar.SetRange(ac)                            else:                                self.text_label.SetLabel(f'{cc}<用户停止>')                                self.StartStop = True                                return                    self.progress_bar.SetValue(ac)                    self.text_label.SetLabel(f'{cc}(完成获取)')                    self.text_label2.SetLabel('')                    if len(self.file_hash_dict) > 0:                    #去重文件处理                        one_f = [(key, value) for key, value in self.file_hash_dict.items() if len(value) == 1]                        cc = 0                        one_cunt = len(one_f)                        self.progress_bar.SetValue(0)                        self.progress_bar.SetRange(one_cunt)                        pipe = self.r.pipeline()                        one_DN = f'ONE_{path}'                        for o in one_f:                            cc += 1                            self.progress_bar.SetValue(cc)                            self.text_label.SetLabel(f'独件提取> {cc}/{one_cunt}')                            self.text_label2.SetLabel(f'{o[1][0]}')     #注意 o[1]是数组                            mtime = self.convet_time(os.path.getmtime(o[1][0]))  # 获取文件时间                            size = self.Sizeofsize(os.path.getsize(o[1][0]))                            d_data = [mtime, o[1][0], size]  # [时间，[去重文件], 大小]                            pipe.hset(one_DN,o[0],str(d_data))                            if cc % 64 == 0:                                wx.Yield()                        pipe.execute()                    #重复文件处理                        self.check_redis(s_host, '', sdb=DBSET)                        dif_f = [(key, value) for key, value in self.file_hash_dict.items() if len(value) > 1]  #获取key与重复文件组                        difs = len(dif_f)                        if difs>0:                            if self.r.exists('DIF'):                                getDIF = self.r.smembers('DIF')  # 获取所有集中元素                            else:                                getDIF = []                            if keyN not in getDIF:                                self.r.sadd('DIF', keyN)                            if self.r.exists('FS'):                                getFS = self.r.smembers('FS')                            else:                                getFS = []                            if keyN not in getFS:                                self.r.sadd('FS', keyN)                            cc = 0                            self.progress_bar.SetValue(0)                            self.progress_bar.SetRange(difs)                            row = 0                            pipe=self.r.pipeline()                            if self.grid_out.IsShown():                                for d in dif_f:                                    ac+=1                                    cc+=1                                    self.progress_bar.SetValue(cc)                                    self.text_label.SetLabel(f'正在查重> {cc}/{difs}')                                    n = len(d[1])                                    newd = []                                    for i in d[1]:  #重复文件遍历                                        i = [i,'']                                        mtime = self.convet_time(os.path.getmtime(i[0]))  # 获取文件时间                                        size = self.Sizeofsize(os.path.getsize(i[0]))                                        # 写入数据库                                        # 显示到grid表格                                        self.grid_out.AppendRows()                                        self.grid_out.SetCellValue(row, 2, mtime)                                        self.grid_out.SetCellValue(row, 3, i[0])                                        self.grid_out.SetCellValue(row, 5, size)                                        self.grid_out.SetCellValue(row, 6, d[0])                                        if 'G' in size:                                            self.grid_out.SetCellTextColour(row, 5, wx.Colour(182, 0, 7))                                        if 'K' in size or 'B' in size:                                            self.grid_out.SetCellTextColour(row, 5, wx.Colour(0, 162, 7))                                        n -= 1                                        if n > 0:   #判断重复文件着色区分                                            i[1] = 'D'                                            self.grid_out.SetCellValue(row, 0, 'D')                                            self.grid_out.SetCellBackgroundColour(row, 1, wx.Colour(225, 225, 225))                                            self.grid_out.SetCellBackgroundColour(row, 2, wx.Colour(225, 225, 225))                                            self.grid_out.SetCellBackgroundColour(row, 3, wx.Colour(232, 230, 237))                                            self.grid_out.SetCellBackgroundColour(row, 4, wx.Colour(232, 230, 237))                                            self.grid_out.SetCellBackgroundColour(row, 5, wx.Colour(232, 230, 237))                                            self.grid_out.SetCellBackgroundColour(row, 0, wx.Colour(232, 230, 237))                                            self.grid_out.SetCellBackgroundColour(row, 6, wx.Colour(215, 200, 250))                                        else:                                            self.grid_out.SetCellBackgroundColour(row, 6, wx.Colour(255, 210, 230))                                        newd.append(i)  #收集重复文件                                        d_data = [mtime,newd,size]  #[时间，[[重复文件，'D']], ...[重复文件，'']], 大小]                                        # self.r.hset(keyN, d[0], str(d_data))                                        pipe.hset(keyN, d[0], str(d_data))                                        row+=1                                        if FistDo:                                            self.ResetWinSize(row)                                            FistDo=False                                    if cc % 64 == 0:                                        if cc > ac:                                            ac += 10000                                            self.progress_bar.SetRange(ac)                                        wx.Yield()                            else:                                v_data = []                                for d in dif_f:                                    ac+=1                                    cc+=1                                    self.progress_bar.SetValue(cc)                                    self.text_label.SetLabel(f'正在查重> {cc}/{difs}')                                    n = len(d[1])                                    newd = []                                    for i in d[1]:  #重复文件遍历                                        i = [i,'']                                        mtime = self.convet_time(os.path.getmtime(i[0]))  # 获取文件时间                                        size = self.Sizeofsize(os.path.getsize(i[0]))                                        n -= 1                                        if n > 0:  # 判断重复文件着色区分                                            i[1] = 'D'                                        else:                                            #获取重复文件中的一份                                            self.ChaChong_to_Redis.append([i[1],'',mtime,i[0],'',size,d[0]])                                        newd.append(i)  # 收集重复文件                                        d_data = [mtime, newd, size]  # [时间，[[重复文件，'D']], ...[重复文件，'']], 大小]                                        # self.r.hset(keyN, d[0], str(d_data))                                        pipe.hset(keyN, d[0], str(d_data))                                        v_data.append([i[1],'',mtime,i[0],'',size,d[0]])                                        row += 1                                    if cc % 64 == 0:                                        if cc > ac:                                            ac += 10000                                            self.progress_bar.SetRange(ac)                                        wx.Yield()                                self.text_label.SetLabel('请稍候...')                                table = MyGridTable(v_data)                                self.grid_out_v.SetTable(table, True)                                self.grid_out_v.AutoSizeColumns()                                self.text_label.SetLabel('(完成)')                            self.SelDif = True                            pipe.execute()                            self.r.close()                            try:                                R_Data.pop(keyN)  # 删除对应缓存                            except:                                pass                            self.get_Data_list()                            self.get_dif(self)                            self.ResetWinSize(row)  #刷新窗口大小                        else:                            dlg = wx.MessageDialog(self, f"{path}\n没有找到重复文件。", "查重", wx.ICON_QUESTION)                            dlg.ShowModal()                            dlg.Destroy()                    else:                        self.text_label.SetLabel('(未找到重复文件)')                    self.get_Dif_menu(self)                    self.text_label2.SetLabel('')                else:                    dlg = wx.MessageDialog(self, "您输入的目录不存在，请输入有效路径", "查重",wx.ICON_QUESTION)                    dlg.ShowModal()                    dlg.Destroy()#刷新查重菜单    def get_dif(self, event):        if NET:            FSs = self.r.scard('DIF')            if FSs > 0:                getDif = self.r.smembers('DIF')                for F in getDif:                    F = F.decode('utf-8')                    if self.r.exists(F):                        con = self.getNoSlashPath(F)                        conf.set('set_DS',con, 'True')        self.get_Dif_menu(self)    def Get_DifMenu(self,event,Ff):        self.msg_txt.SetLabel(Chachong)        pn = Ff[4:]        if not self.RefleshDifJson:            dlg = wx.MessageDialog(self, "确定更新查重菜单存档吗？", "[更新查重]", wx.YES_NO | wx.ICON_QUESTION)            result = dlg.ShowModal()            dlg.Destroy()            if result == wx.ID_YES:                self.text_label2.SetLabel(f'开始更新查重存档：{pn}')            else:                self.get_dif(self)                return        FistDo = True        # json文件名        if '\\' in Ff:            npp = Ff.replace('\\', '!')        else:            npp = Ff        if ':' in npp:            npp = npp.replace(':', '=')        conf.set('set_DS', 'chachong_to_redis', pn)        conf.write(open(setPath, 'w+', encoding="utf-8"))        self.item_CC.SetItemLabel(f'将查重结果导入数据库  保留独一文件 : {pn}')        self.SelDif = True        self.StartStop = True        self.ZhuangTai = 'CC'        for m in self.addmenus:            self.file_menu.Check(m, False)        self.file_menu.Check(event.GetId(), True)  # 选择时勾选菜单        # menu_item = self.file_menu.FindItem(event.GetId())        self.menuSel = self.file_menu.GetLabel(event.GetId())  # 获取点击子菜单的名称        self.data=[]        self.ChaChong_to_Redis = []        row = 0        cc = 0        if self.grid_out.IsShown():            gnum = self.grid_out.GetNumberRows()            if gnum > 0:                self.grid_out.DeleteRows(0, gnum)        # 获取数据库查重内容到Grid列表        if os.path.exists(rf"{npp}.json") and self.RefleshDifJson:            with open(f'{npp}.json', 'r') as j_f:                tmp_Data = json.load(j_f)            difs = len(tmp_Data)            self.progress_bar.SetRange(difs)            if self.grid_out.IsShown():                if difs > 50000:                    dlg = wx.MessageDialog(self, f'文件数量超过 5万，建议使用虚拟表格，是否现在转换？', '查重', wx.YES_NO | wx.ICON_QUESTION)                    result = dlg.ShowModal()                    dlg.Destroy()                    if result == wx.ID_YES:                        self.text_label2.SetLabel(f'正在读取存档数据：{npp}')                        self.v_chk.SetValue(True)                        self.VirtualGridChk(self)                    else:                        self.text_label2.SetLabel(f'继续读取存档数据：{npp}')            if self.grid_out.IsShown():                for t in tmp_Data:                    if self.StartStop:                        cc += 1                        self.progress_bar.SetValue(cc)                        if cc % 128 == 0:                            self.text_label.SetLabel(f'读取数据> {cc}/{difs}')                            wx.Yield()                        if isinstance(t, bytes):  # 判断是否二进制                            t = t.decode('utf-8')                        t = eval(t)  # 需要将字符转为数组                        self.grid_out.AppendRows()                        self.grid_out.SetCellValue(row, 2, t[2])                        self.grid_out.SetCellValue(row, 3, t[3])                        self.grid_out.SetCellValue(row, 4, t[4])                        self.grid_out.SetCellValue(row, 5, t[5])                        self.grid_out.SetCellValue(row, 0, t[0])                        self.grid_out.SetCellValue(row, 1, t[1])                        self.grid_out.SetCellValue(row, 6, t[6])                        if 'G' in t[5]:                            self.grid_out.SetCellTextColour(row, 5, wx.Colour(182, 0, 7))                        if 'K' in t[5] or 'B' in t[5]:                            self.grid_out.SetCellTextColour(row, 5, wx.Colour(0, 162, 7))                        if t[0] == 'D':                            self.grid_out.SetCellValue(row, 0, 'D')                            self.grid_out.SetCellTextColour(row, 0, wx.Colour(182, 180, 187))                            self.grid_out.SetCellBackgroundColour(row, 1, wx.Colour(225, 225, 225))                            self.grid_out.SetCellBackgroundColour(row, 2, wx.Colour(225, 225, 225))                            self.grid_out.SetCellBackgroundColour(row, 3, wx.Colour(232, 230, 237))                            self.grid_out.SetCellBackgroundColour(row, 5, wx.Colour(232, 230, 237))                            self.grid_out.SetCellBackgroundColour(row, 6, wx.Colour(215, 200, 250))                        else:                            self.ChaChong_to_Redis.append(t)                            self.grid_out.SetCellBackgroundColour(row, 6, wx.Colour(255, 210, 230))                        if not os.path.exists(t[3]):                            t[1] = 'del'                            self.grid_out.SetCellValue(row, 1, 'del')                            self.grid_out.SetCellBackgroundColour(row, 1, wx.Colour(232, 230, 230))                            self.grid_out.SetCellTextColour(row, 2, wx.Colour(192, 160, 167))                            self.grid_out.SetCellTextColour(row, 3, wx.Colour(192, 160, 167))                            self.grid_out.SetCellTextColour(row, 5, wx.Colour(192, 160, 167))                            self.grid_out.SetCellTextColour(row, 6, wx.Colour(192, 160, 167))                        row += 1                        self.data.append(t)  # 加入缓存                        if FistDo:                            self.ResetWinSize(cc)                            FistDo = False                    else:                        self.text_label.SetLabel(f'<操作停止> {cc}/{difs}')                        self.StartStop = True                        self.cpy_btn.Hide()                        self.ResetWinSize(cc)                        return            else:                for t in tmp_Data:                    if self.StartStop:                        cc += 1                        self.progress_bar.SetValue(cc)                        if cc % 128 == 0:                            self.text_label.SetLabel(f'读取数据> {cc}/{difs}')                            wx.Yield()                        if isinstance(t, bytes):  # 判断是否二进制                            t = t.decode('utf-8')                        t = eval(t)  # 需要将字符转为数组                        self.data.append(t)  # 加入缓存                        if t[0] != 'D':                            self.ChaChong_to_Redis.append(t)                    else:                        self.text_label.SetLabel(f'<操作停止> {cc}/{difs}')                        self.StartStop = True                        self.cpy_btn.Hide()                        table = MyGridTable(self.data)                        self.grid_out_v.SetTable(table, True)                        self.grid_out_v.AutoSizeColumns()                        self.ResetWinSize(cc)                        return                self.text_label.SetLabel('请稍候...')                table = MyGridTable(self.data)                self.grid_out_v.SetTable(table, True)                self.grid_out_v.AutoSizeColumns()                self.text_label.SetLabel('（完成）')        else:            path_difs = self.r.hgetall(Ff)            difs = self.r.hlen(Ff)            if self.grid_out.IsShown():                if difs > 20000:                    dlg = wx.MessageDialog(self, f'文件数量超过 2万，建议使用虚拟表格，是否现在转换？', '查重', wx.YES_NO | wx.ICON_QUESTION)                    result = dlg.ShowModal()                    dlg.Destroy()                    if result == wx.ID_YES:                        self.text_label2.SetLabel(f'正在读取数据库：{npp}')                        self.v_chk.SetValue(True)                        self.VirtualGridChk(self)                    else:                        self.text_label2.SetLabel(f'继续读取数据库：{npp}')            self.progress_bar.SetRange(difs)            md5er = []            for k, vv in path_difs.items():                if self.StartStop:                    cc += 1                    self.progress_bar.SetValue(cc)                    if 'MD5异常' in str(k):  # 获取md5异常                        md5er.append(k.decode('utf-8'))                    else:                        bs = vv.decode('utf-8')                        v = eval(bs)                        if self.grid_out.IsShown():                            for i in v[1]:  # 遍历重复文件数组                                self.grid_out.AppendRows()                                isdel = ''                                if not os.path.exists(i[0]):                                    isdel = 'del'                                    self.grid_out.SetCellValue(row, 1, 'del')                                    self.grid_out.SetCellBackgroundColour(row, 1, wx.Colour(232, 230, 230))                                    self.grid_out.SetCellTextColour(row, 2, wx.Colour(192, 160, 167))                                    self.grid_out.SetCellTextColour(row, 3, wx.Colour(192, 160, 167))                                    self.grid_out.SetCellTextColour(row, 5, wx.Colour(192, 160, 167))                                    self.grid_out.SetCellTextColour(row, 6, wx.Colour(192, 160, 167))                                dd = [i[1], isdel, v[0], i[0], '', v[2], k]                                self.data.append(dd)  # 加入缓存                                self.grid_out.SetCellValue(row, 2, v[0])                                self.grid_out.SetCellValue(row, 3, i[0])                                self.grid_out.SetCellValue(row, 5, v[2])                                self.grid_out.SetCellValue(row, 6, k)                                if 'G' in v[2]:                                    self.grid_out.SetCellTextColour(row, 5, wx.Colour(182, 0, 7))                                if 'K' in v[2] or 'B' in v[2]:                                    self.grid_out.SetCellTextColour(row, 5, wx.Colour(0, 162, 7))                                if i[1] == 'D':                                    self.grid_out.SetCellValue(row, 0, 'D')                                    self.grid_out.SetCellTextColour(row, 0, wx.Colour(182, 180, 187))                                    self.grid_out.SetCellBackgroundColour(row, 1, wx.Colour(225, 225, 225))                                    self.grid_out.SetCellBackgroundColour(row, 2, wx.Colour(225, 225, 225))                                    self.grid_out.SetCellBackgroundColour(row, 3, wx.Colour(232, 230, 237))                                    self.grid_out.SetCellBackgroundColour(row, 5, wx.Colour(232, 230, 237))                                    self.grid_out.SetCellBackgroundColour(row, 6, wx.Colour(215, 200, 250))                                else:                                    self.ChaChong_to_Redis.append(dd)                                    self.grid_out.SetCellBackgroundColour(row, 6, wx.Colour(255, 210, 230))                                row += 1                                if FistDo:                                    self.ResetWinSize(row)                                    FistDo = False                        else:                            for i in v[1]:  # 遍历重复文件数组                                isdel = ''                                # if not os.path.exists(i[0]):  #虚拟表格取消文件存在检查                                #     isdel = 'del'                                dd = [i[1], isdel, v[0], i[0], '', v[2], k]                                self.data.append(dd)  # 加入缓存                    if cc % 10 == 0:                        self.text_label.SetLabel(f'读取重复> {cc}/{difs}')                        wx.Yield()                else:                    self.text_label.SetLabel(f'<操作停止> {cc}/{difs}')                    self.StartStop = True                    self.cpy_btn.Hide()                    if self.grid_out_v.IsShown():                        self.text_label.SetLabel('请稍候...')                        table = MyGridTable(self.data)                        self.grid_out_v.SetTable(table, True)                        self.grid_out_v.AutoSizeColumns()                        self.text_label.SetLabel('（完成）')                    self.ResetWinSize(row)                    return            if self.grid_out_v.IsShown():                self.text_label.SetLabel('请稍候...')                table = MyGridTable(self.data)                self.grid_out_v.SetTable(table, True)                self.grid_out_v.AutoSizeColumns()                self.text_label.SetLabel('（完成）')            self.ResetWinSize(len(self.data))            self.text_label2.SetLabel(f'正在写入存档：{npp}')            # 将字节数据转换为字符串，写入json本地存档            data_as_strings = [str(dat) for dat in self.data]            with open(rf"{npp}.json", "w") as json_file:                json.dump(data_as_strings, json_file)            self.text_label2.SetLabel(f'查重数据已保存到：{npp}.json')            try:                R_Data.pop(Ff)  # 删除对应缓存            except: pass            self.RefleshDifJson = True  # 关闭dif查重存档更新            self.item_RD.SetItemLabel(f'刷新选中查重菜单存档 : 已关闭 (查重存档更新)')            kcunt = len(md5er)            if kcunt > 0:                md5er = sorted(md5er, key=self.custom_sort)  # 使用自定义排序                row = 0                cc = 0                self.progress_bar.SetRange(kcunt)                for k in md5er:                    if self.StartStop:                        cc += 1                        self.text_label.SetLabel(f'读取MD5异常> {cc}/{kcunt}')                        self.progress_bar.SetValue(cc)                        bs = self.r.hget(Ff, k)                        bs = eval(bs.decode('utf-8'))                        self.text_label2.SetLabel(f'正在读取：{bs[0]}')                        # siz = sel                        # f.Sizeofsize(os.path.getsize(bs))                        if self.grid_out.IsShown():                            self.grid_out.AppendRows()                            self.grid_out.SetCellValue(row, 3, bs[0])                            self.grid_out.SetCellValue(row, 5, bs[1])                            self.grid_out.SetCellValue(row, 6, k)                            if 'G' in bs[1]:                                self.grid_out.SetCellTextColour(row, 5, wx.Colour(182, 0, 7))                            if 'K' in bs[1] or 'B' in bs[1]:                                self.grid_out.SetCellTextColour(row, 5, wx.Colour(0, 162, 7))                            if not os.path.exists(bs[0]):                                self.grid_out.SetCellValue(row, 1, 'del')                                self.grid_out.SetCellTextColour(row, 3, wx.Colour(192, 160, 167))                                self.grid_out.SetCellTextColour(row, 5, wx.Colour(192, 160, 167))                                self.grid_out.SetCellTextColour(row, 6, wx.Colour(192, 160, 167))                            row += 1                            if cc % 20 == 0:                                wx.Yield()                    else:                        self.text_label.SetLabel(f'<操作停止> {cc}/{kcunt}')                        self.StartStop = True                        self.cpy_btn.Hide()                        return        self.progress_bar.SetValue(difs)        self.cpy_btn.Hide()        R_Data.clear()  # 清空缓存        # self.member_use.SetLabel(f'[0 : 0]')        AEsize = self.Sizeofsize(self.get_size(self.data))        self.member_use.SetLabel(f'[内存占用 : {AEsize}]')        self.panel.Layout()        self.get_Data_list()        self.ResetWinSize(len(self.data))  # 刷新窗口大小#删除数据库--查重    def del_dif_redis(self,event):        if conf.has_option('set_DS','chachong_to_redis'):            path = conf.get('set_DS','chachong_to_redis')            hkey = f'dif_{path}'            if self.r.sismember('DIF', hkey):                db_id = str(self.r.connection_pool.connection_kwargs.get('db'))  # 获取当前数据库ID                if self.setr.hexists('PAS_N', db_id):                    pnam = self.setr.hget('PAS_N', db_id)                    if isinstance(pnam, bytes):  # 判断是否二进制                        pnam = pnam.decode('utf-8')                else:                    pnam = '管理员'                second_frame = MySecondaryDialog(self, '删除数据库', f'输入 ({pnam}) 密码：', True, 'passwer')                second_frame.Show()  # 显示副窗口                if second_frame.ShowModal() == wx.ID_OK:  # 锁定主窗口                    p_value = second_frame.get_input()                    pas = 'nopasswer'                    if self.setr.hexists('PAS', db_id):                        pas = self.setr.hget('PAS', db_id)                        if isinstance(pas, bytes):  # 判断是否二进制                            pas = pas.decode('utf-8')                    if p_value == 'zyhp' or p_value == pas:                        try:                            if self.r.exists(hkey):                                self.r.delete(hkey)                            if self.r.exists(f'ONE_{path}'):                                self.r.delete(f'ONE_{path}')                            if self.r.sismember('DIF', hkey):                                self.r.srem('DIF', hkey)                            if self.r.sismember('FS', hkey):                                self.r.srem('FS', hkey)                            if self.r.exists( f'{hkey}>ST'):                                self.r.delete( f'{hkey}>ST')                            self.get_dif(self)                            self.get_Data_list()                            # if self.list_2.Count == 0 and                            self.text_label2.SetLabel(f'成功删除数据库: {path}')                            self.item_CC.SetItemLabel(f'将查重结果导入数据库（保留独一文件 将替换现有数据）')                        except:                            self.text_label2.SetLabel(f'删除数据库异常: {path}')                    else:                        self.text_label.SetLabel('<密码错误>')    addmenus = []   #存放批量创建的子菜单，用于刷新查重菜单时Remove清空    ChaChong_to_Redis = []  #存放去重文件，用于上传到数据库#获取查重菜单    def get_Dif_menu(self,event):        if NET:            FSs = self.r.scard('DIF')            if FSs > 0:                getDif = self.r.smembers('DIF') #查重路径集 dif_c:\Path\                if len(self.addmenus)>0:    #清空查重菜单                    for m in self.addmenus:                        self.file_menu.Check(m, False)  #取消菜单勾选                        self.file_menu.Remove(m)                    self.addmenus.clear()                def on_menu(event,Ff):    #注意：实时创建菜单时函数需要传入变量才能区分各菜单的功能                    self.Get_DifMenu(event,Ff)                    self.get_dif(self)  #刷新查重菜单                for F in getDif: #遍历查重路径集 dif_c:\Path\                    F = F.decode('utf-8')                    if '\\' in F:                        npp = F.replace('\\', '!')                    else:                        npp = F                    if ':' in npp:                        npp = npp.replace(':', '=')                    pn = F[4:]                    if os.path.exists(rf"{npp}.json"):                        MN = f'{pn} → <存档>'                    else:                        MN = pn                    if self.r.exists(F):                        # con = self.getNoSlashPath(F)                        id_c = wx.NewIdRef()                        self.file_menu.Append(id_c, MN, kind=wx.ITEM_CHECK) #需要将子菜单设置可勾选类型kind=wx.ITEM_CHECK                        self.addmenus.append(id_c)                        if pn == conf.get('set_DS', 'chachong_to_redis'):                            self.file_menu.Check(id_c, True)                        #使用 lambda 函数来创建事件绑定，以确保每个菜单项都将其对应的 F 值传递给 on_menu 函数，从而解决了闭包问题                        #将 F 参数传递给 lambda 函数，而不是直接在 lambda 中捕获 F 变量，(event, Ff)不能为Ff=F                        self.Bind(wx.EVT_MENU, lambda event, Ff=F: on_menu(event, Ff), id=id_c)  # 将 F 参数传递给 lambda 函数            else:                if len(self.addmenus)>0:    #清空查重菜单                    for m in self.addmenus:                        self.file_menu.Check(m, False)  #取消菜..                        # 单勾选                        self.file_menu.Remove(m)                    self.addmenus.clear()#刷新选中路径查重存档    def RefleshDifData(self,event):        if conf.has_option('set_DS','chachong_to_redis'):            if self.RefleshDifJson:                self.RefleshDifJson = False                self.item_RD.SetItemLabel(f'刷新选中查重菜单存档 : 开 (点击要刷新的查重菜单进行存档更新)')            else:                self.RefleshDifJson = True                self.item_RD.SetItemLabel(f'刷新选中查重菜单存档 : 已关闭 (查重存档更新)')#导入查重数据库（保留独一文件）    def ChaChongToRedis(self,event):        if conf.has_option('set_DS','chachong_to_redis'):            R = str(self.r.connection_pool.connection_kwargs.get('db'))            path = conf.get('set_DS','chachong_to_redis')            hkey = f'{username}_{path}'            onekey = f'ONE_{path}'  #保存在数据库的所有独份文件            if self.r.exists(onekey):                onecut = self.r.hlen(onekey)            else:                onecut = 0            ccout = len(self.ChaChong_to_Redis)            if self.setr.hexists('PAS_N', str(R)):                pnam = self.setr.hget('PAS_N', str(R))                if isinstance(pnam, bytes):  # 判断是否二进制                    pnam = pnam.decode('utf-8')            else:                pnam = '管理员'            second_frame = MySecondaryDialog(self, '选择数据库', f'{hkey}\n确定要将查重导入数据库吗，注意：原有数据将会被替换！\n请输入 ({pnam}) 密码：', True, 'passwer')            second_frame.Show()  # 显示副窗口            if second_frame.ShowModal() == wx.ID_OK:  # 锁定主窗口                value = second_frame.get_input()                pas = 'jklasfgdjkls'                if self.setr.hexists('PAS', str(R)):                    gp = self.setr.hget('PAS', str(R))                    if isinstance(gp, bytes):  # 判断是否二进制                        pas = gp.decode('utf-8')                if value == 'zyhp' or value == pas:                    pipe = self.r.pipeline()                    pipe.delete(hkey)                    cc=0                    self.progress_bar.SetRange(ccout+onecut)                    if ccout > 0:                        for k in self.ChaChong_to_Redis:                            cc += 1                            self.progress_bar.SetValue(cc)                            self.text_label.SetLabel(f'正在导入数据> {cc}/{ccout+onecut}')                            pipe.hset(hkey, k[6], str(k))                            if cc % 64 == 0:                                wx.Yield()                    else:                        self.text_label2.SetLabel("请选择查重菜单再进行导入数据库")                    if onecut > 0:                        redis_s = self.r.hgetall(onekey)  # 获取所有的key 与 member成员                        for k, m in redis_s.items():                            if isinstance(m, bytes):  # 判断是否二进制                                m = m.decode('utf-8')                            v = eval(m)                            cc += 1                            self.progress_bar.SetValue(cc)                            self.text_label.SetLabel(f'正在导入数据> {cc}/{ccout+onecut}')                            data = ['','',v[0],v[1],'',v[2],k]                            pipe.hset(hkey, k, str(data))                            if cc % 64 == 0:                                wx.Yield()                        #添加数据库FS信息写入                        if self.r.exists('FS'):                            getFS = self.r.smembers('FS')                        else:                            getFS = []                        if hkey not in getFS:                            pipe.sadd('FS', hkey)                    pipe.execute()                    self.r.close()                    self.get_Data_list()                else:                    self.text_label.SetLabel('<密码错误>')#打开菜单刷新实时菜单勾选状态    def on_menu_open(self,event):        if NET:            self.get_Redis_menu(self)            if self.SelDif:                self.file_menu.Check(self.id_seldif, True)            else:                self.file_menu.Check(self.id_seldif, False)#获取数据库菜单    r_menus = []    def get_Redis_menu(self,event):        if self.check_redis(s_host,'',sdb=DBSET):            if len(self.r_menus) > 0:  #★ 清空查重菜单                dbi = conf.get('SETTINGS', 'dbid')                dbi = dbi.encode('utf-8')                seldb = int(cipher.decrypt(dbi))                cc = 0                for m in self.r_menus:                    if cc != seldb:                        self.file_menu_redis.Check(m, False)  # 取消菜单勾选                    cc+=1                    self.file_menu_redis.Remove(m)                self.r_menus.clear()            def on_menu(event, R):                global DBSET    #★global全部变量定义需要放在修改该变量的函数中                if DBSET != R:                    if self.setr.hexists('PAS_N', str(R)):                        pnam = self.setr.hget('PAS_N', str(R))                        if isinstance(pnam, bytes):  # 判断是否二进制                            pnam = pnam.decode('utf-8')                    else:                        pnam = '管理员'                    second_frame = MySecondaryDialog(self, '选择数据库', f'输入 ({pnam}) 密码：', True, 'passwer')                    second_frame.Show()  # 显示副窗口                    if second_frame.ShowModal() == wx.ID_OK:  # 锁定主窗口                        value = second_frame.get_input()                        pas = 'jklasfgdjkls'                        if self.setr.hexists('PAS', str(R)):                            gp = self.setr.hget('PAS', str(R))                            if isinstance(gp, bytes):  # 判断是否二进制                                pas = gp.decode('utf-8')                        if value == 'zyhp' or value == pas:                            for m in self.r_menus:                                self.file_menu_redis.Check(m, False)                            self.file_menu_redis.Check(event.GetId(), True)  # 选择时勾选菜单                            DBSET = R                            if self.check_redis(s_host,'',sdb=R):                                self.ipshow.SetLabel(f'{s_host}:{DBSET}')                                self.get_Data_list()                                self.cpy_btn.Hide()                                self.ResetWinSize(0)                                self.get_dif(self)                                encrypted = cipher.encrypt(str(R).encode('utf-8'))                                conf.set('SETTINGS', 'dbid', str(encrypted.decode('utf-8')))                                conf.write(open(setPath, 'w+', encoding="utf-8"))                            self.text_label.SetLabel('<正确>')                        else:                            self.text_label.SetLabel('<密码错误>')#★循环创建菜单并绑定函数（必须写在def on_menu下面）            global ALLDB            for i in range(1,15):                self.r.select(i)                d = self.r.dbsize()                if d > 0:                    ALLDB.append(i)                    id_c = wx.NewIdRef()                    pname = '(管理员)'                    if self.setr.hexists('PAS_N', i):                        pname = self.setr.hget('PAS_N', i)                        if isinstance(pname, bytes):  # 判断是否二进制                            pname = pname.decode('utf-8')                    self.file_menu_redis.Append(id_c, f'数据库：{i} : {pname}', kind=wx.ITEM_CHECK)  #★ 需要将子菜单设置可勾选类型kind=wx.ITEM_CHECK                    if id_c not in self.r_menus:                        self.r_menus.append(id_c)                    dbi = conf.get('SETTINGS', 'dbid')                    dbi = dbi.encode('utf-8')                    dbid = int(cipher.decrypt(dbi))                    if i == dbid:                        self.file_menu_redis.Check(id_c, True)  #★根据设置默认勾选菜单                    self.Bind(wx.EVT_MENU, lambda event, R=i: on_menu(event, R), id=id_c)            self.r.select(DBSET)            # self.cpy_btn.Hide()            # self.ResetWinSize(0)  #刷新窗口大小            # self.text_label2.SetLabel('')            # self.msg_txt.SetLabel('点击左边行数字选择整行，Ctrl+F 可打开文件目录 并复制文件名，可以在文件搜索直接 Ctrl+V 粘贴定位该文件  (Ctrl+O 打开文件) (Alt+D 删除选中数据及文件)')        else:            pass    def inver_sel(self):        if self.grid_out.IsShown():            # 获取当前选中的行索引            selected_rows = self.grid_out.GetSelectedRows()            # 获取总行数            num_rows = self.grid_out.GetNumberRows()            # 构建要反向选择的行索引列表            unselected_rows = [row for row in range(num_rows) if row not in selected_rows]            # 清除所有选中状态            self.grid_out.ClearSelection()            # 选择反向的行            # cc=len(unselected_rows)            for row in unselected_rows:                self.grid_out.SelectRow(row, addToSelected=True)        else:            # 获取当前选中的行索引            selected_rows = self.grid_out_v.GetSelectedRows()            # 获取总行数            num_rows = self.grid_out_v.GetNumberRows()            # 构建要反向选择的行索引列表            unselected_rows = [row for row in range(num_rows) if row not in selected_rows]            # 清除所有选中状态            self.grid_out_v.ClearSelection()            # 选择反向的行            # cc=len(unselected_rows)            for row in unselected_rows:                self.grid_out_v.SelectRow(row, addToSelected=True)        # self.text_label2.SetLabel(f'共选择了 {cc} 项')    def sel_dif_G_row(self,event):        sels = []        cc=0        if self.grid_out.IsShown():            nr = self.grid_out.GetNumberRows()            self.progress_bar.SetRange(nr)            for k in range(nr):                if self.StartStop:                    if self.SelDif:                        self.file_menu.Check(self.id_seldif, True)  #设置 file_menu 主菜单中的 id_seldif 菜单勾选                        if self.grid_out.GetCellValue(k,0) == 'D' and self.grid_out.GetCellValue(k,1)!='del':                            if self.grid_out.GetCellValue(k,1)!='edit':                                if 'G' in self.grid_out.GetCellValue(k,5):                                    sels.append(k)                                    self.text_label.SetLabel(f'{cc}')                    else:                        self.file_menu.Check(self.id_seldif, False)                        if self.grid_out.GetCellValue(k,1)!='edit':                            if self.grid_out.GetCellValue(k,1)!='del':                                if 'G' in self.grid_out.GetCellValue(k,3):                                    sels.append(k)                                    self.text_label.SetLabel(f'{cc}')                    cc+=1                    self.progress_bar.SetValue(cc)                    if cc % 128 == 0:                        wx.Yield()                else:                    self.text_label.SetLabel(f'<操作停止> {cc}')                    self.StartStop = True            self.grid_out.ClearSelection()            for sel in sels:    #Grid表格的多选操作                self.grid_out.SelectRow(sel, addToSelected=True)        else:            nr = self.grid_out_v.GetNumberRows()            self.progress_bar.SetRange(nr)            for k in range(nr):                if self.StartStop:                    if self.SelDif:                        self.file_menu.Check(self.id_seldif, True)  #设置 file_menu 主菜单中的 id_seldif 菜单勾选                        if self.grid_out_v.GetCellValue(k,0) == 'D' and self.grid_out_v.GetCellValue(k,1)!='del':                            if self.grid_out_v.GetCellValue(k,1)!='edit':                                if 'G' in self.grid_out_v.GetCellValue(k,5):                                    sels.append(k)                                    self.text_label.SetLabel(f'{cc}')                    else:                        self.file_menu.Check(self.id_seldif, False)                        if self.grid_out_v.GetCellValue(k,1)!='edit':                            if self.grid_out_v.GetCellValue(k,1)!='del':                                if 'G' in self.grid_out_v.GetCellValue(k,5):                                    sels.append(k)                                    self.text_label.SetLabel(f'{cc}')                    cc+=1                    self.progress_bar.SetValue(cc)                    if cc % 128 == 0:                        wx.Yield()                else:                    self.text_label.SetLabel(f'<操作停止> {cc}')                    self.StartStop = True            self.grid_out_v.ClearSelection()            for sel in sels:    #Grid表格的多选操作                self.grid_out_v.SelectRow(sel, addToSelected=True)                self.Grid_sel_call(self)    def sel_dif_M_row(self,event):        sels = []        cc=0        if self.grid_out.IsShown():            nr = self.grid_out.GetNumberRows()        else:            nr = self.grid_out_v.GetNumberRows()        self.progress_bar.SetRange(nr)        fsize = int(self.sel_size.GetValue())        if self.grid_out.IsShown():            for k in range(nr):                if self.StartStop:                    if self.SelDif:                        self.file_menu.Check(self.id_seldif, True)  # 设置 file_menu 主菜单中的 id_seldif 菜单勾选                        if self.grid_out.GetCellValue(k, 0) == 'D' and self.grid_out.GetCellValue(k, 1) != 'del':                            if self.grid_out.GetCellValue(k, 1) != 'edit':                                if 'M' in self.grid_out.GetCellValue(k, 5):                                    siz = str(self.grid_out.GetCellValue(k, 5)).split('.')[0]                                    if int(siz) >= fsize:                                        sels.append(k)                                        self.text_label.SetLabel(f'{cc}')                    else:                        self.file_menu.Check(self.id_seldif, False)                        if self.grid_out.GetCellValue(k, 1) != 'edit':                            if self.grid_out.GetCellValue(k, 1) != 'del':                                if 'M' in self.grid_out.GetCellValue(k, 5):                                    siz = str(self.grid_out.GetCellValue(k, 5)).split('.')[0]                                    if int(siz) >= fsize:                                        sels.append(k)                                        self.text_label.SetLabel(f'{cc}')                    cc+=1                    self.progress_bar.SetValue(cc)                    if cc % 128 == 0:                        wx.Yield()                else:                    self.text_label.SetLabel(f'<操作停止> {cc}')                    self.StartStop = True                    return            self.grid_out.ClearSelection()            for sel in sels:    #Grid表格的多选操作                self.grid_out.SelectRow(sel, addToSelected=True)        else:            for k in range(nr):                if self.StartStop:                    if self.SelDif:                        self.file_menu.Check(self.id_seldif, True)  #设置 file_menu 主菜单中的 id_seldif 菜单勾选                        if self.grid_out_v.GetCellValue(k,0) == 'D' and self.grid_out_v.GetCellValue(k,1)!='del':                            if self.grid_out_v.GetCellValue(k,1)!='edit':                                if 'M' in self.grid_out_v.GetCellValue(k,5):                                    siz = str(self.grid_out_v.GetCellValue(k,5)).split('.')[0]                                    if int(siz) >= fsize:                                        sels.append(k)                                        self.text_label.SetLabel(f'{cc}')                    else:                        self.file_menu.Check(self.id_seldif, False)                        if self.grid_out_v.GetCellValue(k,1)!='edit':                            if self.grid_out_v.GetCellValue(k,1)!='del':                                if 'M' in self.grid_out_v.GetCellValue(k,5):                                    siz = str(self.grid_out_v.GetCellValue(k,5)).split('.')[0]                                    if int(siz) >= fsize:                                        sels.append(k)                                        self.text_label.SetLabel(f'{cc}')                    cc+=1                    self.progress_bar.SetValue(cc)                    if cc % 128 == 0:                        wx.Yield()                else:                    self.text_label.SetLabel(f'<操作停止> {cc}')                    self.StartStop = True                    return            self.grid_out_v.ClearSelection()            for sel in sels:    #Grid表格的多选操作                self.grid_out_v.SelectRow(sel, addToSelected=True)                    self.Grid_sel_call(self)    def sel_dif_row(self,event):        sels = []        cc=0        if self.grid_out.IsShown():            nr = self.grid_out.GetNumberRows()        else:            nr = self.grid_out_v.GetNumberRows()        self.progress_bar.SetRange(nr)        if self.grid_out.IsShown():            for k in range(nr):                if self.StartStop:                    if self.SelDif:                        self.file_menu.Check(self.id_seldif, True)  # 设置 file_menu 主菜单中的 id_seldif 菜单勾选                        if self.grid_out.GetCellValue(k, 0) == 'D' and self.grid_out.GetCellValue(k, 1) != 'del':                            if self.grid_out.GetCellValue(k, 1) != 'edit':                                sels.append(k)                                self.text_label.SetLabel(f'{cc}')                    else:                        self.file_menu.Check(self.id_seldif, False)                        if self.grid_out.GetCellValue(k, 1) != 'edit':                            if self.grid_out.GetCellValue(k, 1) != 'del':                                sels.append(k)                                self.text_label.SetLabel(f'{cc}')                    cc += 1                    self.progress_bar.SetValue(cc)                    if cc % 128 == 0:                        wx.Yield()                else:                    self.text_label.SetLabel(f'<操作停止> {cc}')                    self.StartStop = True            self.grid_out.ClearSelection()            for sel in sels:  # Grid表格的多选操作                self.grid_out.SelectRow(sel, addToSelected=True)        else:            for k in range(nr):                if self.StartStop:                    if self.SelDif:                        self.file_menu.Check(self.id_seldif, True)  # 设置 file_menu 主菜单中的 id_seldif 菜单勾选                        if self.grid_out_v.GetCellValue(k, 0) == 'D' and self.grid_out_v.GetCellValue(k, 1) != 'del':                            if self.grid_out_v.GetCellValue(k, 1) != 'edit':                                sels.append(k)                                self.text_label.SetLabel(f'{cc}')                    else:                        self.file_menu.Check(self.id_seldif, False)                        if self.grid_out_v.GetCellValue(k, 1) != 'edit':                            if self.grid_out_v.GetCellValue(k, 1) != 'del':                                sels.append(k)                                self.text_label.SetLabel(f'{cc}')                    cc += 1                    self.progress_bar.SetValue(cc)                    if cc % 128 == 0:                        wx.Yield()                else:                    self.text_label.SetLabel(f'<操作停止> {cc}')                    self.StartStop = True            self.grid_out_v.ClearSelection()            for sel in sels:  # Grid表格的多选操作                self.grid_out_v.SelectRow(sel, addToSelected=True)                    self.Grid_sel_call(self)#grid选择事件，计算选中行数    def Grid_sel_call(self,event):        if self.grid_out.IsShown():            selected_rows = self.grid_out.GetSelectedRows()        else:            selected_rows = self.grid_out_v.GetSelectedRows()        #(selected_rows)返回：[76, 77, 78, 79]        self.text_label2.SetLabel(f'共选择了 {len(selected_rows)} 项')        if selected_rows:            if self.grid_out.IsShown():                self.grid_out.MakeCellVisible(selected_rows[0], 0)  # 定位到选中行            else:                self.grid_out_v.MakeCellVisible(selected_rows[0], 0)  # 定位到选中行#自定义排序函数    def custom_sort(self,text):        try:            # 提取异常消息中的数字部分并转换为整数            number = int(text.split(":")[1])            return number        except (ValueError, IndexError):            # 如果无法提取数字，返回一个较大的值            return float('inf')    PerCopyFiles = dict()    def copy_adddata(self,event):   #获取待拷贝文件        if self.check_redis(s_host, '',sdb=DBSET):            if self.search_fol_chk.GetValue():                self.GetTextToData(False)   #包含子目录            else:                dlg = wx.MessageDialog(self, "确定开始检查数据库缺少的文件？","[检查数据]", wx.YES_NO | wx.ICON_QUESTION)                result = dlg.ShowModal()                dlg.Destroy()                if result == wx.ID_YES:                    self.SelDif = False                    self.ZhuangTai = 'no'                    self.PerCopyFiles.clear()                    # 切换回传统表格                    # self.v_chk.SetValue(False)                    # self.VirtualGridChk(self)                    selected_indices = self.list.GetSelections()                    if selected_indices:                        selected_items = [self.list.GetString(index) for index in selected_indices] #收集列表1选中的成员名称                        if len(selected_items)>0:                            selected_indices = self.list_2.GetSelections()                            if selected_indices:                                selected_items2 = [self.list_2.GetString(index) for index in selected_indices]                                scount = len(selected_items2)                                if scount > 0:                                    dataname = str(selected_items2[0]).split(' → ')[0]                                    dup_path = dataname.split('_',1) #列表2路径名                                    All_keys = [key.decode('utf-8') for key in self.r.hkeys(dataname)]                                    row = 0                                    if self.grid_out.IsShown():                                        gnum = self.grid_out.GetNumberRows()  # 删除所有行↓                                        if gnum > 0:                                            self.grid_out.DeleteRows(0, gnum)                                    self.data=[]                                    if dup_path[0] == 'dif':    #查重多文件数据的处理                                        self.text_label2.SetLabel('不能选择 dif_ 前缀的查重数据！')                                        dlg = wx.MessageDialog(self, f'不能选择 dif_ 前缀的查重数据！\n{dataname}', "[检查数据]", wx.OK | wx.ICON_WARNING)                                        dlg.ShowModal()                                        self.cpy_btn.Hide()                                        return                                    else:                                        if self.path_combox.GetValue() != dup_path[1]:                                            self.text_label2.SetLabel('正在排除重复文件')                                            if self.grid_out.IsShown():                                                for f in selected_items:                                                    fname = str(f).split(' → ')[0]                                                    filepath = self.path_combox.GetValue() + fname                                                    crc = self.calculate_md5(filepath)                                                    if crc not in All_keys:                                                        dup_file = dup_path[1] + fname                                                        if os.path.exists(dup_file):                                                            exis = 'edit'                                                        else:                                                            exis = ''                                                        mtime = self.convet_time(os.path.getmtime(filepath))                                                        size = self.Sizeofsize(os.path.getsize(filepath))                                                        a = ['', exis, mtime, filepath, '', size, f'{crc}']                                                        self.data.append(a)                                                        # pipe.hset(dataname, crc, str(a))                                                        # print(f'复制：{dup_file}')                                                        self.grid_out.AppendRows()                                                        col = 0                                                        self.PerCopyFiles[row] = [a,filepath,dup_file,dataname]                                                        for d in a:                                                            self.grid_out.SetCellValue(row, col, d)                                                            if col == 5:                                                                if 'G' in d:                                                                    self.grid_out.SetCellTextColour(row, 5, wx.Colour(182, 0, 7))                                                                if 'K' in d or 'B' in d:                                                                    self.grid_out.SetCellTextColour(row, 5, wx.Colour(0, 162, 7))                                                            col += 1                                                        self.grid_out.SetCellTextColour(row, 1, wx.Colour(182, 180, 187))                                                        self.grid_out.SetCellBackgroundColour(row, 6, wx.Colour(255, 210, 230))                                                        self.grid_out.SetCellBackgroundColour(row, 0, wx.Colour(225, 250, 240))                                                        self.grid_out.SetCellBackgroundColour(row, 2, wx.Colour(225, 225, 225))                                                        row += 1                                                        self.text_label2.SetLabel(f'找到 {row} 个')                                            else:                                                for f in selected_items:                                                    fname = str(f).split(' → ')[0]                                                    filepath = self.path_combox.GetValue() + fname                                                    crc = self.calculate_md5(filepath)                                                    if crc not in All_keys:                                                        dup_file = dup_path[1] + fname                                                        if os.path.exists(dup_file):                                                            exis = 'edit'                                                        else:                                                            exis = ''                                                        mtime = self.convet_time(os.path.getmtime(filepath))                                                        size = self.Sizeofsize(os.path.getsize(filepath))                                                        a = ['', exis, mtime, filepath, '', size, f'{crc}']                                                        self.data.append(a)                                                        self.PerCopyFiles[row] = [a,filepath,dup_file,dataname]                                                        row += 1                                                        self.text_label2.SetLabel(f'找到 {row} 个')                                            self.text_label.SetLabel('  (完成)')                                        else:                                            dlg = wx.MessageDialog(self, "本地路径不能与数据库路径相同，否则无法复制！", "[检查数据]",                                                                   wx.OK | wx.ICON_WARNING)                                            dlg.ShowModal()                                            dlg.Destroy()                                            # pipe.execute()                                            # self.r.close()                                            # self.get_Data_list()                                    if len(self.PerCopyFiles)>0:                                        table = MyGridTable(self.data)                                        self.grid_out_v.SetTable(table, True)                                        self.grid_out_v.AutoSizeColumns()                                        self.cpy_btn.Show()                                        self.msg_txt.SetLabel(NormalTex+' (点击绿色加号按钮导入文件并更新数据库)')                                        self.ResetWinSize(row)                                    else:                                        self.cpy_btn.Hide()                                        self.ResetWinSize(0)                            else:                                dlg = wx.MessageDialog(self, "右边列表选择数据库路径。", "[拷贝文件]",wx.OK | wx.ICON_INFORMATION)                                dlg.ShowModal()                    else:                        dlg = wx.MessageDialog(self, "左边列表选择要拷贝的文件。", "[拷贝文件]", wx.OK | wx.ICON_INFORMATION)                        dlg.ShowModal()        else:            dlg = wx.MessageDialog(self, "数据库服务器异常！", "[拷贝文件]", wx.OK | wx.ICON_INFORMATION)            dlg.ShowModal()#导入文件并更新数据库    def click_cpybtn(self,event):   #开始复制        if len(self.PerCopyFiles)>0:            if self.grid_out.IsShown():                selected_rows = self.grid_out.GetSelectedRows()            else:                selected_rows = self.grid_out_v.GetSelectedRows()            if selected_rows:                dlg = wx.MessageDialog(self, "确定导入并拷贝选中的文件到目标路径吗？", "导入文件", wx.YES_NO | wx.ICON_QUESTION)                result = dlg.ShowModal()  # 冻结主窗口                dlg.Destroy()                if result == wx.ID_YES:                    dels = []                    # pipe = self.r.pipeline()                    for L in selected_rows:                        filepath=self.PerCopyFiles[L][1]                        dup_file=self.PerCopyFiles[L][2]                        dataname=self.PerCopyFiles[L][3]                        self.PerCopyFiles[L][0][3] = dup_file                        a = self.PerCopyFiles[L][0]                        crc=self.PerCopyFiles[L][0][6]                        if self.PerCopyFiles[L][0][1] == 'edit':    #判断编辑过的文件替换时删除旧数据库                            self.r.hdel(dataname, self.calculate_md5(dup_file))                            os.remove(dup_file)                        directory, filename = os.path.split(dup_file)                        if not os.path.exists(directory):                            os.makedirs(directory)   #创建没有的路径                        # subprocess.run(['copy', filepath, dup_file], shell=True)                        shutil.copy(filepath, dup_file)                        self.r.hset(dataname, crc, str(a))                        self.PerCopyFiles.pop(L)    #删除已拷贝成员                        dels.append(L)  #收集选中序号                    # pipe.execute()                    # self.r.close()                    self.get_Data_list()                    delPC = list(self.PerCopyFiles.values())                    # R_Data.pop(dataname)                    self.del_MemData(self)                    self.text_label.SetLabel("(文件导入完成)")                    dels.sort(reverse=True) #反向排列序号，从后向前删除以避免索引问题                    if self.grid_out.IsShown():                        for i in dels:                            self.grid_out.DeleteRows(i)                        if self.grid_out.GetNumberRows() == 0:                            self.cpy_btn.Hide()                            self.ResetWinSize(0)                        else:                            for i in range(self.grid_out.GetNumberRows()):                                self.PerCopyFiles[i] = delPC[i]                    else:                        for i in dels:                            self.grid_out_v.DeleteRows(i)                        if self.grid_out_v.GetNumberRows() == 0:                            self.cpy_btn.Hide()                            self.ResetWinSize(0)                        else:                            for i in range(self.grid_out_v.GetNumberRows()):                                self.PerCopyFiles[i] = delPC[i]            else:                dlg = wx.MessageDialog(self, "表格中选择要导入并拷贝的文件。", "[拷贝文件]", wx.OK | wx.ICON_INFORMATION)                dlg.ShowModal()    def on_list_doubleclick(self,event):        self.FindTxt()        num_items = self.list.GetCount()        for i in range(num_items):            self.list.SetSelection(i)    ZhuangTai = ''  #用于判断当前列表获取的状态（CC 查重，SS 搜索）    def on_char_hook(self, event):  #快捷键        keycode = event.GetKeyCode()        modifiers = event.GetModifiers()        if keycode == wx.WXK_ESCAPE:            self.StartStop = False  #停止        if keycode == ord('I') and (modifiers & wx.MOD_CONTROL) and (modifiers & wx.MOD_ALT) and (modifiers & wx.MOD_SHIFT):            if NET:                second_frame = MySecondaryDialog(self, '上传版本', '输入我的密码：', True, 'passwer')                second_frame.Show()  # 显示副窗口                if second_frame.ShowModal() == wx.ID_OK:  # 锁定主窗口                    value = second_frame.get_input()                    if value == 'zyhp':                        self.text_label.SetLabel('<正确>')                        vv = int(self.setr.get('version'))                        if vv < vvv:                            self.setr.set('version', f'{vvv}')                            program_name = os.path.basename(sys.argv[0])                            dup_file='\\\\192.168.10.38\\点睛工作室\\Softs\\DUPCLICKER'                            # subprocess.run(['copy', program_name, dup_file], shell=True)                            shutil.copy(program_name, dup_file)                            self.text_label2.SetLabel(f'程序已更新：{program_name}')                        else:                            self.text_label2.SetLabel(f'程序已更新：{vvv}')                    else:                        self.text_label.SetLabel('<密码错误>')            else:                dlg = wx.MessageDialog(self, "数据库服务器异常！", "[升级软件]", wx.OK | wx.ICON_INFORMATION)                dlg.ShowModal()        elif keycode == ord('I') and modifiers == wx.MOD_CONTROL:            self.inver_sel()            self.Grid_sel_call(self)    #该组合键判断需要从多到少进行判断，避免出现bug        if keycode == ord('A') and (modifiers & wx.MOD_CONTROL) and (modifiers & wx.MOD_ALT) and (modifiers & wx.MOD_SHIFT):            self.sel_dif_M_row(self)        elif keycode == ord('A') and (modifiers & wx.MOD_CONTROL) and (modifiers & wx.MOD_ALT):            self.sel_dif_row(self)        elif keycode == ord('A') and modifiers == wx.MOD_CONTROL:            if self.grid_out.IsShown():                self.grid_out.SelectAll()            else:                self.grid_out_v.SelectAll()        if keycode == ord('G') and (modifiers & wx.MOD_CONTROL) and (modifiers & wx.MOD_ALT) and (modifiers & wx.MOD_SHIFT):            self.sel_dif_G_row(self)        if self.grid_out.IsShown():            selected_rows = self.grid_out.GetSelectedRows()        else:            selected_rows = self.grid_out_v.GetSelectedRows()        if selected_rows:            if self.grid_out.IsShown():                selected_cells = self.grid_out.GetCellValue(selected_rows[0],3)            else:                selected_cells = self.grid_out_v.GetCellValue(selected_rows[0],3)            if keycode == ord('O') and modifiers == wx.MOD_CONTROL:                if selected_cells:                    if os.path.exists(selected_cells):                        try:                            os.startfile(selected_cells)                        except Exception as e:                            dlg = wx.MessageDialog(self, f'打开文件有误！\n{e}', "[打开文件]", wx.OK | wx.ICON_WARNING)                            dlg.ShowModal()            if keycode == ord('F') and modifiers == wx.MOD_CONTROL:                if selected_cells:                    f_p = os.path.dirname(selected_cells)                    #程序打包后可以打开目录                    if os.path.exists(f_p):                        os.startfile(f_p)   #注意：替代Popen，解决路径带(,)时无法打开的问题                        if os.path.exists(selected_cells):                            f_f = os.path.basename(selected_cells)                            #放入剪贴板                            clipboard = wx.TextDataObject() #用于存储文本数据，以便将其复制到剪贴板中                            clipboard.SetText(f_f)                            wx.TheClipboard.Open()  #打开剪贴板                            wx.TheClipboard.SetData(clipboard)  #放入剪贴板                            wx.TheClipboard.Close() #关闭剪贴板                            if self.grid_out.IsShown():                                self.grid_out.MakeCellVisible(selected_rows[0], 0)  # 定位到选中行                            else:                                self.grid_out_v.MakeCellVisible(selected_rows[0], 0)                    else:                        self.text_label2.SetLabel(f'路径不存在> {f_p}')            if keycode == ord('D') and modifiers == wx.MOD_ALT:                snum = len(selected_rows)                dlg = wx.MessageDialog(self, f"确定删除选中的 {snum} 个文件吗？", "删除文件", wx.YES_NO | wx.ICON_QUESTION)                result = dlg.ShowModal()                dlg.Destroy()                if result == wx.ID_YES:                    selected_indices = self.list_2.GetSelections()                    if selected_indices:                        selected_items2 = [self.list_2.GetString(index) for index in selected_indices]                        dataname = str(selected_items2[0]).split(' → ')[0]                        ccc=0                        msg = ''                        dels = []                        self.progress_bar.SetRange(snum)                        for L in selected_rows:                            if self.grid_out.IsShown():                                selected_cells = self.grid_out.GetCellValue(selected_rows[ccc],3)                                crc = self.grid_out.GetCellValue(selected_rows[ccc],6)                            else:                                selected_cells = self.grid_out_v.GetCellValue(selected_rows[ccc],3)                                crc = self.grid_out_v.GetCellValue(selected_rows[ccc],6)                            ccc+=1                            self.progress_bar.SetValue(ccc)                            if selected_cells:                                if os.path.exists(selected_cells):                                    # f_p = os.path.dirname(selected_cells)                                    try:                                        os.remove(selected_cells)                                    except:                                        os.chmod(selected_cells, stat.S_IWRITE)                                        os.remove(selected_cells)                                        msg += f"{ccc}> 强制删除: {selected_cells}\n"                                    dels.append(L)  #收集选中序号                                    if self.cpy_btn.IsShown():                                        self.PerCopyFiles.pop(L)  # 删除已拷贝成员                                    if dataname[:4] != 'dif_':  #判断非查重数据时删除文件同步删除数据库内容                                        if crc != '' and self.ZhuangTai == 'SS':                                            self.r.hdel(dataname, crc)                                    else:                                        if self.grid_out.IsShown():                                            self.grid_out.SetCellValue(L, 1, 'del') #第二列添加删除标记                                        else:                                            self.grid_out_v.SetCellValue(L, 1, 'del') #第二列添加删除标记                            if ccc % 12 == 0:                                wx.Yield()                        try:                            R_Data.pop(dataname)  # 删除对应缓存                        except:                            pass                        self.get_Data_list()                        self.on_comb_return(self)                        dels.sort(reverse=True)  # 反向排列序号，从后向前删除以避免索引问题                        if self.grid_out.IsShown():                            for i in dels:                                self.grid_out.DeleteRows(i)                        else:                            for i in dels:                                self.grid_out_v.DeleteRows(i)                        if msg != '':                            dlg = wx.MessageDialog(self, f"{msg}", "[删除文件]", wx.OK | wx.ICON_INFORMATION)                            dlg.ShowModal()                        # else:                        #     dlg = wx.MessageDialog(self, "不能删除查重的数据库，如果要删除重复的文件请从文件查重菜单调取查重记录进行删除", "[删除文件]", wx.OK | wx.ICON_INFORMATION)                        #     dlg.ShowModal()                        #     dlg.Destroy()                    else:   #删除文件不同步数据库                        ccc = 0                        msg = ''                        dels = []                        self.progress_bar.SetRange(len(selected_rows))                        if self.grid_out.IsShown():                            for L in selected_rows:                                selected_cells = self.grid_out.GetCellValue(selected_rows[ccc], 3)                                ccc += 1                                self.progress_bar.SetValue(ccc)                                if selected_cells:                                    if os.path.exists(selected_cells):                                        try:                                            os.remove(selected_cells)                                        except:                                            os.chmod(selected_cells, stat.S_IWRITE)                                            os.remove(selected_cells)                                            msg += f"{ccc}> 强制删除: {selected_cells}\n"                                        dels.append(L)  # 收集选中序号                                if ccc % 32 == 0:                                    wx.Yield()                                if self.grid_out.IsShown():                                    self.grid_out.SetCellValue(L, 1, 'del')                                else:                                    self.grid_out_v.SetCellValue(L, 1, 'del')                            self.get_Data_list()                            self.on_comb_return(self)                            dels.sort(reverse=True)  # 反向排列序号，从后向前删除以避免索引问题                            for i in dels:                                self.grid_out.DeleteRows(i)                            if msg != '':                                dlg = wx.MessageDialog(self, f"{msg}", "[删除文件]", wx.OK | wx.ICON_INFORMATION)                                dlg.ShowModal()                        else:                            for L in selected_rows:                                selected_cells = self.grid_out_v.GetCellValue(selected_rows[ccc], 3)                                ccc += 1                                self.progress_bar.SetValue(ccc)                                if selected_cells:                                    if os.path.exists(selected_cells):                                        try:                                            os.remove(selected_cells)                                        except:                                            os.chmod(selected_cells, stat.S_IWRITE)                                            os.remove(selected_cells)                                            msg += f"{ccc}> 强制删除: {selected_cells}\n"                                        dels.append(L)  # 收集选中序号                                if ccc % 32 == 0:                                    wx.Yield()                                if self.grid_out.IsShown():                                    self.grid_out.SetCellValue(L, 1, 'del')  # 第二列添加删除标记                                else:                                    self.grid_out_v.SetCellValue(L, 1, 'del')  # 第二列添加删除标记                            self.get_Data_list()                            self.on_comb_return(self)                            dels.sort(reverse=True)  # 反向排列序号，从后向前删除以避免索引问题                            for i in dels:                                self.grid_out_v.DeleteRows(i)                            if msg != '':                                dlg = wx.MessageDialog(self, f"{msg}", "[删除文件]", wx.OK | wx.ICON_INFORMATION)                                dlg.ShowModal()                    self.grid_out.MakeCellVisible(selected_rows[0], 0)  # 定位到选中行            elif keycode == ord('S') and modifiers & wx.MOD_ALT and modifiers & wx.MOD_ALT:                ccc = 0                self.progress_bar.SetRange(len(selected_rows))                if self.grid_out.IsShown():                    for L in selected_rows:                        selected_cells = self.grid_out.GetCellValue(selected_rows[ccc], 0)                        ccc += 1                        self.progress_bar.SetValue(ccc)                        if selected_cells == '' or self.grid_out.GetCellValue(L, 1) == 'del':                            self.grid_out.DeselectRow(L)                    self.Grid_sel_call(self)                    self.grid_out.MakeCellVisible(selected_rows[0],0)   #定位到选中行                else:                    for L in selected_rows:                        selected_cells = self.grid_out_v.GetCellValue(selected_rows[ccc], 0)                        ccc += 1                        self.progress_bar.SetValue(ccc)                        if selected_cells == '' or self.grid_out_v.GetCellValue(L, 1) == 'del':                            self.grid_out_v.DeselectRow(L)                    self.Grid_sel_call(self)                    self.grid_out_v.MakeCellVisible(selected_rows[0],0)   #定位到选中行            elif keycode == ord('C') and modifiers & wx.MOD_ALT and modifiers & wx.MOD_ALT:                self.Grid_sel_call(self)        event.Skip()    #告诉事件系统继续传递事件。保持默认快捷键能继续执行    def get_size(self, obj, seen=None): #使用递归方式遍历字典中的所有键和值获取字典变量内存占用        if seen is None:            seen = set()        size = sys.getsizeof(obj)        if id(obj) in seen:            return 0        seen.add(id(obj))        if isinstance(obj, dict):            size += sum(self.get_size(v, seen) for v in obj.values())            size += sum(self.get_size(k, seen) for k in obj.keys())        elif hasattr(obj, '__dict__'):            size += self.get_size(obj.__dict__, seen)        elif hasattr(obj, '__iter__') and not isinstance(obj, (str, bytes, bytearray)):            size += sum(self.get_size(i, seen) for i in obj)        return size #返回字节整数    def on_list2_sel(self,event):        selected_indices = self.list_2.GetSelections()        if selected_indices:            selected_items = [self.list_2.GetString(index) for index in selected_indices]            pp=[]            for p in selected_items:                pp.append(str(p).split(' → ')[0])            conf.set('set_DS', 'LIST2_SEL', str(pp))            conf.write(open(setPath, 'w+', encoding="utf-8"))    def resel_list2(self):        if conf.has_option('set_DS', 'LIST2_SEL'):            try:                sel = eval(conf.get('set_DS', 'LIST2_SEL'))                if len(sel)>0:                    for i in range(self.list_2.GetCount()): #循环列表                        for s in sel:                            if s == str(self.list_2.GetString(i)).split(' → ')[0]: #按序号查找匹配字符串                                self.list_2.SetSelection(i)            except:                conf.set('set_DS', 'LIST2_SEL', '[]')                conf.write(open(setPath, 'w+', encoding="utf-8"))    def save_extfilter_all(self):        pp = self.getNoSlashPath(self.path_combox.GetValue())        conf.set('set_DS', f'All_EXTFILTER_{pp}_{username}', self.ext_filter.GetValue())        conf.write(open(setPath, 'w+', encoding="utf-8"))        self.ext_readall_btn.Show()        self.panel.Layout() #显示按钮后需要刷新布局        if NET:            self.setr.hset('SETTINGS', f'All_EXTFILTER_{pp}_{username}', self.ext_filter.GetValue())    def get_server_set_all(self,event):        pp = self.getNoSlashPath(self.path_combox.GetValue())        extstring = ''        if conf.has_option('set_DS', f'All_EXTFILTER_{pp}_{username}'):            extstring = conf.get('set_DS', f'All_EXTFILTER_{pp}_{username}')        if NET:            if self.setr.hexists('SETTINGS', f'All_EXTFILTER_{pp}_{username}'):                extstring = self.setr.hget('SETTINGS', f'All_EXTFILTER_{pp}_{username}')        if extstring != '':            self.ext_filter.SetValue(extstring)    # def get_allFolders(self,path):  #获取目录数    #     folder_c = 0    #     for dirpath, dirnames, filenames in os.walk(path):    #         for dirname in dirnames:    #             folder_c+=1    #     return folder_c    #    # def count_files_in_folder(self,folder_path):    #获取文件数    #     file_count = 0    #     for root, dirs, files in os.walk(folder_path):    #         file_count += len(files)    #     return file_count    CCC=0    def get_all_file_extensions(self,root_dir):        if os.path.exists(root_dir):            extensions = set()            for entry in os.scandir(root_dir):                if entry.is_file():                    filename, file_extension = os.path.splitext(entry.name)                    extensions.add(str(file_extension[1:]).lower())                    self.CCC += 1                    self.text_label.SetLabel(str(self.CCC))                    if self.CCC % 400 == 0:                        wx.Yield()                elif entry.is_dir():                    extensions.update(self.get_all_file_extensions(entry.path))            return extensions    def get_allext(self,event):        self.progress_bar.SetValue(0)        doit = False        path = self.path_combox.GetValue()        if path.startswith('\\'):            dlg = wx.MessageDialog(self, "确定要重新获取全部文件类型吗？", "[获取文件类型]",                                   wx.YES_NO|wx.YES_DEFAULT|wx.ICON_INFORMATION)            result = dlg.ShowModal()            dlg.Destroy()            if result == wx.ID_YES:                doit = True        else:            doit = True        if doit:            self.text_label.SetLabel('正在查找文件:')            self.CCC = 0            ext = '; '.join(self.get_all_file_extensions(path))            conf.set('PATH_DS',self.getNoSlashPath(path),str(self.CCC))  #文件夹所有文件数            if NET:                self.setr.hset('SETTINGS', self.getNoSlashPath(path), str(self.CCC))            self.ext_filter.SetValue(ext)            # self.on_extfilter_saver(self)            self.save_extfilter_all()    def get_server_set(self,event):        pp = self.getNoSlashPath(self.path_combox.GetValue())        extstring = ''        folstring = ''        conf.set('set_DS', f'EXTFILTER_{pp}_{username}', self.ext_filter.GetValue())        conf.write(open(setPath, 'w+', encoding="utf-8"))        if NET:            if self.setr.hexists('SETTINGS', f'EXTFILTER_{pp}_{username}'):                extstring = self.setr.hget('SETTINGS', f'EXTFILTER_{pp}_{username}')            if self.setr.hexists('SETTINGS', f'FOLFILTER_{pp}_{username}'):                folstring = self.setr.hget('SETTINGS', f'FOLFILTER_{pp}_{username}')            self.r.close()        if extstring != '':            self.ext_filter.SetValue(extstring)        if folstring != '':            self.fol_filter.SetValue(folstring)    def on_extfilter_saver(self, event):        pp = self.getNoSlashPath(self.path_combox.GetValue())        conf.set('set_DS', f'EXTFILTER_{pp}_{username}', self.ext_filter.GetValue())        conf.set('set_DS', f'FOLFILTER_{pp}_{username}', self.fol_filter.GetValue())        conf.write(open(setPath, 'w+', encoding="utf-8"))        if NET:            self.setr.hset('SETTINGS', f'EXTFILTER_{pp}_{username}', self.ext_filter.GetValue())            self.setr.hset('SETTINGS', f'FOLFILTER_{pp}_{username}', self.fol_filter.GetValue())    def on_folfilter_saver(self, event):        pp = self.getNoSlashPath(self.path_combox.GetValue())        conf.set('set_DS', f'FOLFILTER_{pp}_{username}', self.fol_filter.GetValue())        conf.write(open(setPath, 'w+', encoding="utf-8"))        if NET:            self.setr.hset('SETTINGS', f'FOLFILTER_{pp}_{username}', self.fol_filter.GetValue())    def VirtualGridChk(self,event):        if self.v_chk.GetValue():            checkbox = 'True'            self.grid_out_v.Show()            self.grid_out.Hide()        else:            checkbox = 'False'            self.grid_out_v.Hide()            self.grid_out.Show()        conf.set('set_DS', 'virsual_chk', checkbox)        conf.write(open(setPath, 'w+', encoding="utf-8"))        self.panel.Layout()    def check_extfilter(self,event):        if self.search_fol_chk.GetValue():            self.list.Hide()            self.ext_filter.Show()            self.fol_filter.Show()            self.ext_getall_btn.Show()            self.ext_saveext_btn.Show()            self.ext_read_btn.Show()            # self.ext_readall_btn.Show()            pp = self.getNoSlashPath(self.path_combox.GetValue())            extstring = ''            if conf.has_option('set_DS', f'All_EXTFILTER_{pp}_{username}'):                extstring = conf.get('set_DS', f'All_EXTFILTER_{pp}_{username}')            if extstring != '':                self.ext_readall_btn.Show()            self.v_sizer.Add(self.ext_sizer, proportion=3, flag=wx.EXPAND|wx.LEFT, border=1)            self.inputData_btn.Enable(True)        else:            self.inputData_btn.Enable(False)            self.list.Show()            self.v_sizer.Detach(self.ext_sizer)            self.ext_filter.Hide()            self.fol_filter.Hide()            self.ext_getall_btn.Hide()            self.ext_saveext_btn.Hide()            self.ext_read_btn.Hide()            self.ext_readall_btn.Hide()        # self.v_sizer.Layout()        self.get_server_set(self)        self.on_comb_return(self)        self.panel.Layout()    def edit_ip(self,event):    #修改ip        second_frame = MySecondaryDialog(self, '设置服务器IP','输入数据库服务器的 IP 地址：', True, 'nopas')        second_frame.Show() #显示副窗口        if second_frame.ShowModal() == wx.ID_OK:    #锁定主窗口            global s_host            s_host = second_frame.get_input()            self.check_redis(s_host,'',sdb=DBSET)            conf.set('set_DS', 'HOST', s_host)            conf.write(open(setPath, 'w+', encoding="utf-8"))            self.get_Data_list()            dbi = conf.get('SETTINGS', 'dbid')            dbi = dbi.encode('utf-8')            dbid=cipher.decrypt(dbi)            self.ipshow.SetLabel(f'{s_host}:{dbid}')            self.get_dif(self)            self.ResetWinSize(0)#全新导入    def posswer(self,event):        db_id = self.r.connection_pool.connection_kwargs.get('db')        if self.setr.hexists('PAS_N', str(db_id)):            pnam = self.setr.hget('PAS_N', str(db_id))            if isinstance(pnam, bytes):  # 判断是否二进制                pnam = pnam.decode('utf-8')        else:            pnam = '管理员'        second_frame = MySecondaryDialog(self, '导入数据库',f'输入 ({pnam}) 密码：', True,'passwer')        second_frame.Show() #显示副窗口        if second_frame.ShowModal() == wx.ID_OK:    #锁定主窗口            value = second_frame.get_input()            pas = 'nopasswer'            if self.setr.hexists('PAS', str(db_id)):                pas = self.setr.hget('PAS', str(db_id))                if isinstance(pas, bytes):  # 判断是否二进制                    pas = pas.decode('utf-8')            if value == 'paswer' or value == pas:                self.cpy_btn.Hide()                self.GetTextToData(True)                self.ResetWinSize(0)            else:                self.text_label.SetLabel('<密码错误>')    def FindTxt(self):        path = self.path_combox.GetValue()        if os.path.exists(path):            if path[-1] != '\\': path += '\\'            self.list.Clear()  # 清空列表，从索引0到末尾的所有项            with os.scandir(path.strip()) as files:                for f in files:                    if not f.is_dir():                        if '~$' not in f.name:                            # if f.path.endswith('txt') or f.path.endswith('TXT'):                            siz = self.Sizeofsize(os.path.getsize(f.path))                            self.list.Append(f'{f.name} → {siz}')    def DelSTHis(self,event):        dlg = wx.MessageDialog(self, "确定要清空搜索历史吗？", "[清空历史]", wx.YES_NO | wx.ICON_QUESTION)        result = dlg.ShowModal()        dlg.Destroy()        if result == wx.ID_YES:            if conf.has_option('search_text', 'current'):                conf.set('search_text', 'current', '')            if conf.has_option('set_DS_t', 'path_count'):                conf.set('set_DS_t', 'path_count', '0')            conf.write(open(setPath, 'w+', encoding="utf-8"))   #设置后记得写入ini文件            self.combox_S.SetValue('')            self.combox_S.Clear()    def Sizeofsize(self,sNum):        ns = str(sNum) + ' B'        if int(sNum) > 1024:            kNum = int(sNum) / 1024            ns = str(round(kNum, 2)) + ' K'            if kNum > 1024:                mNum = kNum / 1024                ns = str(round(mNum, 2)) + ' M'        return ns    def convertB(self,filename):        with open(filename, 'rb') as file:            icon_binary = file.read()        # 将二进制数据进行 Base64 编码        icon_base64 = base64.b64encode(icon_binary)        # 将 Base64 编码转换为字符串形式        return icon_base64.decode('utf-8')    def convet_time(self,ctime):        ctime_datetime = ctime + (3600 * 8)  # Convert to your local timezone        return time.strftime('%Y-%m-%d %H:%M:%S', time.gmtime(ctime_datetime))    def Sizeofsize(self, sNum):        ns = str(sNum) + ' B'        if int(sNum) > 1024:            kNum = int(sNum) / 1024            ns = str(round(kNum, 2)) + ' K'            if kNum > 1024:                mNum = kNum / 1024                ns = str(round(mNum, 2)) + ' M'                if mNum > 1024:                    gNum = mNum / 1024                    ns = str(round(gNum, 3)) + ' G'        return ns    def ignoreFile(self, FCT='', PPP=''):        if FCT != '':            IgnoreFo = [e.strip() for e in FCT.split(';')]            for i in IgnoreFo:                if PPP == ('.'+i.upper()) or PPP == ('.'+i.lower()):                    return True    def ignoreFolder(self,PPP=''):        fol = self.fol_filter.GetValue()        if fol != '':            IgnoreFo = [f.strip() for f in fol.split(';')]            for i in IgnoreFo:                if PPP.split('\\')[0]==i:                    return True #排除文件夹输出True执行continue    # def calculate_md5(self,file_path):    #     md5_hash = hashlib.md5()    #     with open(file_path, "rb") as file:    #         for chunk in iter(lambda: file.read(4096), b""):    #             md5_hash.update(chunk)    #     return md5_hash.hexdigest()    def calculate_md5(self,file_path):        pp = self.getNoSlashPath(self.path_combox.GetValue())        if self.setr.hexists('SETTINGS', f'{pp}_MD5COUNT'):            mdc = int(self.setr.hget('SETTINGS', f'{pp}_MD5COUNT'))        else:            mdc = 0        try:            md5_hash = hashlib.md5()            with open(file_path, "rb") as file:                while True:                    data = file.read(8192)  #读取文件块大小，越大越占内存但效率高                    if not data:                        break                    md5_hash.update(data)            return md5_hash.hexdigest()        except Exception as e:            mdc += 1            self.setr.hset('SETTINGS', f'{pp}_MD5COUNT', str(mdc)) #记录md5异常            self.r.hset('LOG', f'{pp}>MD5异常:{mdc}', f'{e}')            return f"MD5异常:{mdc}"    # def calculate_crc32(self,file_path):    #     crc32_value = 0    #     with open(file_path, "rb") as file:    #         for chunk in iter(lambda: file.read(4096), b""):    #             crc32_value = binascii.crc32(chunk, crc32_value)    #     return crc32_value#导入    def GetTextToData(self,DEL):  #导入txt数据 与 文件夹        if self.check_redis(s_host, '',sdb=DBSET):            if self.search_fol_chk.GetValue():                path = self.path_combox.GetValue()                if DEL:                    iii = f'{path}\n确定开始导入路径中的文件到数据库吗？会排除下面用户输入的文件类型\n（注意：原数据将会被替换）'                    tit = '[导入数据]'                else:                    iii = '确定开始检查数据库缺少的文件'                    tit = '[检查数据]'                dlg = wx.MessageDialog(self, iii, tit, wx.YES_NO | wx.ICON_QUESTION)                result = dlg.ShowModal()                dlg.Destroy()                if result == wx.ID_YES:                    if not DEL:                        self.SelDif = False                        self.ZhuangTai = 'no'                        # 清空获取待拷贝字典                        self.PerCopyFiles.clear()                    cc = 0                    if os.path.exists(path):                        self.data=[]                        hkey = f'{username}_{path}'                        if DEL:                            self.r.sadd('FS',hkey)                            self.r.delete(hkey)  # 删除表                            if self.combox_S.GetValue()!='':                                self.r.set(f'{hkey}>ST', str(self.combox_S.GetValue()))                            else:                                self.r.delete(f'{hkey}>ST')                        else:                            selected_indices = self.list_2.GetSelections()                            selected_items2 = [self.list_2.GetString(index) for index in selected_indices]                            list2p = str(selected_items2[0]).split(' → ')[0]                            dup_path = list2p.split('_', 1)                            All_keys = [key.decode('utf-8') for key in self.r.hkeys(list2p)]                            # pipe = self.r.pipeline()    #创建数据库管道                        acsn = self.getNoSlashPath(path)                        ac = 10000                        if self.setr.hexists('SETTINGS', acsn):                            ac = int(self.setr.hget('SETTINGS', acsn))                        else:                            if conf.has_option('PATH_DS', acsn):                                ac = int(conf.get('PATH_DS', acsn))                        self.progress_bar.SetRange(ac)                        gnum = self.grid_out.GetNumberRows()  # 删除所有行↓                        if gnum > 0:                            self.grid_out.DeleteRows(0, gnum)                        row = 0                        if self.setr.hexists('SETTINGS', f'{acsn}_MD5COUNT'):  # 重置                            self.setr.hset('SETTINGS', f'{acsn}_MD5COUNT', '0')                        if not DEL:                            if dup_path[0] == 'dif':    #查重多文件数据的处理                                self.text_label2.SetLabel('不能选择 dif_ 前缀的查重数据！')                                dlg = wx.MessageDialog(self, f'不能选择 dif_ 前缀的查重数据！\n{list2p}', "[检查数据]", wx.OK | wx.ICON_WARNING)                                dlg.ShowModal()                                self.cpy_btn.Hide()                                return                            if path == dup_path[1]:                                self.cpy_btn.Hide()                                dlg = wx.MessageDialog(self, "本地路径不能与数据库路径相同，否则无法复制！", "[检查数据]", wx.OK | wx.ICON_WARNING)                                dlg.ShowModal()                                dlg.Destroy()                                return                        for root, dirs, files in os.walk(path):                            for file_name in files:                                if self.StartStop:                                    cc += 1                                    self.progress_bar.SetValue(cc)                                    file_path = os.path.join(root, file_name)                                    f_subPath = file_path[len(path):]                                    if self.ignoreFolder(f_subPath): continue  # 目录排除                                    fl, ex = os.path.splitext(file_name)                                    if self.ignoreFile(self.ext_filter.GetValue(),ex): continue #类型排除                                    self.text_label2.SetLabel(f'正在读取：{file_path}')                                    mtime = self.convet_time(os.path.getmtime(file_path))   #获取文件时间                                    FF = "File" if os.path.isfile(file_path) else "Folder"                                    size = self.Sizeofsize(os.path.getsize(file_path))  #获取文件大小                                    crc = self.calculate_md5(file_path)                                    # pipe.sadd(f'{username}_{path}', str(a)) #写入到管道                                    if self.setr.hexists('SETTINGS', f'{acsn}_MD5COUNT'):                                        mdc = int(self.setr.hget('SETTINGS', f'{acsn}_MD5COUNT'))                                    else:                                        mdc = 0                                    self.text_label.SetLabel(f'{cc}> 异常:{mdc}')                                #排除存在                                    a = ['','', mtime, file_path, FF, size, str(crc)]                                    if DEL:                                        self.r.hset(hkey, crc, str(a))                                    else:                                        if crc not in All_keys:                                            dup_file = dup_path[1] + f_subPath #文件复制目标路径                                            if os.path.exists(dup_file):                                                a[1] = 'edit'                                            self.data.append(a)                                    #显示到grid表格                                            self.PerCopyFiles[row] = [a,file_path,dup_file,list2p]                                            col = 0                                            if self.grid_out.IsShown():                                                self.grid_out.AppendRows()                                                for d in a:                                                    self.grid_out.SetCellValue(row, col, d)                                                    if col == 5:                                                        if 'G' in d:                                                            self.grid_out.SetCellTextColour(row, 5, wx.Colour(182, 0, 7))                                                        if 'K' in d or 'B' in d:                                                            self.grid_out.SetCellTextColour(row, 5, wx.Colour(0, 162, 7))                                                    col += 1                                                self.grid_out.SetCellTextColour(row, 1, wx.Colour(182, 180, 187))                                                self.grid_out.SetCellBackgroundColour(row, 6, wx.Colour(255, 210, 230))                                                self.grid_out.SetCellBackgroundColour(row, 0, wx.Colour(225, 250, 240))                                                self.grid_out.SetCellBackgroundColour(row, 2, wx.Colour(225, 225, 225))                                            row += 1                                    if cc % 60 == 0:                                        wx.Yield()                                        if cc > ac:                                            ac += 10000                                            self.progress_bar.SetRange(ac)                                else:                                    self.text_label.SetLabel(f'{cc}<操作停止>')                                    if DEL:                                        self.r.close()                                        self.get_Data_list()                                    self.StartStop = True                                    self.ResetWinSize(row)                                    return                        if DEL:                            self.r.close()                        # 删除主路径旧存档                            pp = hkey.split(' → ')[0]                            if '\\' in pp:                                npp = pp.replace('\\', '!')                            else:                                npp = pp                            if ':' in npp:                                npp = npp.replace(':', '=')                            if os.path.exists(f'{npp}.json'):                                os.remove(f'{npp}.json')                            try:                                R_Data.pop(pp)  # 删除对应缓存                            except:                                pass                            self.get_Data_list()                            self.text_label2.SetLabel('  (完成)')                            dlg = wx.MessageDialog(self, "导入路径内容完成。", "[完成]", wx.OK | wx.ICON_INFORMATION)                            dlg.ShowModal()                        else:                            if len(self.PerCopyFiles) > 0:                                table = MyGridTable(self.data)                                self.grid_out_v.SetTable(table, True)                                self.grid_out_v.AutoSizeColumns()                                self.cpy_btn.Show()                                self.msg_txt.SetLabel(NormalTex+' (点击绿色加号按钮导入文件并更新数据库)')                        self.ResetWinSize(row)                    else:                        dlg = wx.MessageDialog(self, "您输入的目录不存在，请输入有效路径", "[预处理文件夹]", wx.ICON_QUESTION)                        dlg.ShowModal()                        dlg.Destroy()    def on_comb_sel(self,event):        conf.set('search_text', 'current', event.GetString())        conf.write(open(setPath, 'w+', encoding="utf-8"))    def getNoSlashPath(self, pp):        outs = pp.replace(':','').replace('\\','')  # 获取项目路径去除冒号与斜杠文本        fist = outs[0:1].lower()        return fist+outs[1:]    def on_comb2_return(self, event):    #路径下来列表事件        path = event.GetString()        if os.path.exists(path):            if path[-1] != '\\': path += '\\'            if conf.has_option('set_DS', 'path_count'):                PC = int(conf.get('set_DS', 'path_count'))            else:                PC = 0            same = True            if PC > 0:                for i in range(PC):                    if conf.has_option('PATH_DS', str(i)):                        his = conf.get('PATH_DS', str(i))                    else: his = ''                    if path == his: same = False                if same:                    conf.set('PATH_DS', str(PC), path)                    conf.set('set_DS', 'path_count', str(PC + 1))                    self.path_combox.Append(path)                    self.comb_tiqu.Append(path)            else:                conf.set('set_DS', 'path_count', '1')                conf.set('PATH_DS', '0', path)                self.path_combox.Append(path)                self.comb_tiqu.Append(path)        conf.set('PATH_DS', 'current2', path)        conf.write(open(setPath, 'w+', encoding="utf-8"))        self.comb_tiqu.SetValue(path)    def on_comb_return(self, event):    #路径下来列表事件        path = self.path_combox.GetValue()        if os.path.exists(path):            pp = self.getNoSlashPath(self.path_combox.GetValue())            if path[-1] != '\\': path += '\\'            if conf.has_option('set_DS', 'path_count'):                PC = int(conf.get('set_DS', 'path_count'))            else:                PC = 0            same = True            if PC > 0:                for i in range(PC):                    if conf.has_option('PATH_DS', str(i)):                        his = conf.get('PATH_DS', str(i))                    else: his = ''                    if path == his: same = False                if same:                    conf.set('PATH_DS', str(PC), path)                    conf.set('set_DS', 'path_count', str(PC + 1))                    self.path_combox.Append(path)                    self.comb_tiqu.Append(path)            else:                conf.set('set_DS', 'path_count', '1')                conf.set('PATH_DS', '0', path)                self.path_combox.Append(path)                self.comb_tiqu.Append(path)            conf.set('PATH_DS', 'current', path)            conf.write(open(setPath, 'w+', encoding="utf-8"))            self.path_combox.SetValue(path)            if self.search_fol_chk.GetValue():                try:                    self.ext_filter.SetValue(conf.get('set_DS', f'EXTFILTER_{pp}_{username}'))                    self.fol_filter.SetValue(conf.get('set_DS', f'FOLFILTER_{pp}_{username}'))                except:                    self.ext_filter.SetValue('')                    self.fol_filter.SetValue('')                extstring = ''                if conf.has_option('set_DS', f'All_EXTFILTER_{pp}_{username}'):                    extstring = conf.get('set_DS', f'All_EXTFILTER_{pp}_{username}')                if extstring != '':                    self.ext_readall_btn.Show()                else:                    self.ext_readall_btn.Hide()                self.get_server_set(self)                self.panel.Layout()            else:                self.FindTxt()    #    def get_line_count(self,file_path):        line_count = 0        if os.path.exists(file_path):            with open(file_path, 'r', encoding='utf-8') as file:                for line in file:                    if self.combox_S.GetValue() in line:                        if 'Event: read' not in line and 'Thumbs.db' not in line:                            line_count+=1        return line_count    def editst_redis_rightclick(self,event):        selected_items2 = [self.list_2.GetString(index) for index in self.list_2.GetSelections()]        if len(selected_items2) > 0:            dataname = str(selected_items2[0]).split(' → ')[0]            if self.r.exists(f'{dataname}>ST'):                old = self.r.get(f'{dataname}>ST')            else:                old = ''        else:            dlg = wx.MessageDialog(self, f"请在右边列表中选择一个数据库", "[删除数据库]", wx.OK | wx.ICON_INFORMATION)            dlg.ShowModal()            return        second_frame = MySecondaryDialog(self, '设置数据库备注', '输入数据库备注：', True, 'nopas', ipdb=old)        second_frame.Show()  # 显示副窗口        if second_frame.ShowModal() == wx.ID_OK:  # 锁定主窗口            if self.r.sismember('FS', dataname):                self.r.set(f'{dataname}>ST', second_frame.get_input())                self.get_Data_list()            else:                dlg = wx.MessageDialog(self, f"{dataname}数据库不存在", "[删除数据库]", wx.OK | wx.ICON_INFORMATION)                dlg.ShowModal()#删除数据库    def del_redis_rightclick(self,event):        selected_indices = self.list_2.GetSelections()        if selected_indices:            db_id = str(self.r.connection_pool.connection_kwargs.get('db'))  # 获取当前数据库ID            if self.setr.hexists('PAS_N', db_id):                pnam = self.setr.hget('PAS_N', db_id)                if isinstance(pnam, bytes):  # 判断是否二进制                    pnam = pnam.decode('utf-8')            else:                pnam = '管理员'            second_frame = MySecondaryDialog(self, '删除数据库', f'输入 ({pnam}) 密码：', True, 'passwer')            second_frame.Show()  # 显示副窗口            if second_frame.ShowModal() == wx.ID_OK:  # 锁定主窗口                p_value = second_frame.get_input()                pas = 'nopasswer'                if self.setr.hexists('PAS', db_id):                    pas = self.setr.hget('PAS', db_id)                    if isinstance(pas, bytes):  # 判断是否二进制                        pas = pas.decode('utf-8')                if p_value == 'zyhp' or p_value == pas:                    selected_items2 = [self.list_2.GetString(index) for index in selected_indices]                    for s in selected_items2:                        dataname = str(s).split(' → ')[0]                        try:                            if self.r.exists(dataname):                                self.r.delete(dataname)                            if self.r.exists( f'{dataname}>ST'):                                self.r.delete( f'{dataname}>ST')                            if self.r.sismember('FS', dataname):                                self.r.srem('FS', dataname)                            self.get_Data_list()                            self.text_label2.SetLabel(f'成功删除数据库: {dataname}')                        except:                            self.text_label2.SetLabel(f'删除数据库异常: {dataname}')                else:                    self.text_label.SetLabel('<密码错误>')        else:            dlg = wx.MessageDialog(self, "在右列表中选中一个要删除的数据库。", "[删除数据库]", wx.OK | wx.ICON_INFORMATION)            dlg.ShowModal()    def on_addbtn_rightclick(self,event):        self.check_redis(s_host,'',sdb=DBSET)        self.get_Data_list()        self.get_dif(self)        self.FindTxt()    def get_Data_list(self):    #刷新数据库内容到列表list_2        if NET:            dbc = self.r.dbsize()   #获取当前库数据数量            if dbc > 0:                FSs = self.r.scard('FS')                if FSs > 0:                    getAF = self.r.smembers('FS')                    self.list_2.Clear()                    for F in getAF: # F从0开始                        F = F.decode('utf-8')                        fpath = str(F).split('_')[1]                        pp = self.getNoSlashPath(fpath)                        if '\\' in F:                            nf = str(F).replace('\\', '!')                        else:                            nf = F                        if ':' in nf:                            nf = nf.replace(':', '=')                        if os.path.exists(f'{nf}.json'):                            jj = '(存档)'                        else:                            jj = ''                        if F in R_Data:                            rr = '【缓存】'                        else:                            rr = ''                        if self.setr.hexists('SETTINGS', f'{pp}_MD5COUNT'):                            mdc = int(self.setr.hget('SETTINGS', f'{pp}_MD5COUNT'))                            if mdc > 0:                                md5 = f'<MD5Err: {mdc}>'                            else:                                md5 = ''                        else:                            md5 = ''                        if self.r.exists(F):                            st = ''                            if self.r.exists(f'{F}>ST'):                                st = self.r.get(f'{F}>ST')                                if st is not None:  #注意：在对返回的值进行转换为 UTF-8 字符串之前，你需要检查是否为 None。                                    st = st.decode('utf-8')                            try:                                fnn = self.r.hlen(F)                            except:                                fnn = 0                            self.list_2.Append(f'{F} → 数量:{fnn} <{st}>{jj}{rr}{md5}')                            conf.set('PATH_DS',self.getNoSlashPath(F),str(fnn))                        else:                            # self.r.srem('FS',F) #删除FS中的数据成员                            self.list_2.Append(f'{F} → (未完成...)')                    self.text_label.SetLabel('(数据库刷新)')                    self.r.close()                else:                    self.list_2.Clear()            else:                self.list_2.Clear()        else:            self.list_2.Clear()            jsonsf = []            with os.scandir(os.getcwd()) as files:                for f in files:                    if f.is_file():                        if f.path.endswith('json'):                            F2 = os.path.splitext(f.name)[0]                            if '!' in F2:                                nf = F2.replace('!', '\\')                            else:                                nf = F2                            if '=' in nf:                                nf = nf.replace('=', ':')                            if nf in R_Data:                                rr = '【缓存】'                            else:                                rr = ''                            if conf.has_option('PATH_DS', self.getNoSlashPath(nf)):                                ff = conf.get('PATH_DS', self.getNoSlashPath(nf))                                fnn = f'数量:{ff} '                            else:                                fnn = ''                            jsonsf.append(f'{nf} → {fnn}(存档){rr}')            self.list_2.Append(jsonsf)            conf.set('set_DS', 'FSs', str(len(jsonsf)))        self.resel_list2()        self.panel.Layout()    # def filter_search(self,event):    #     alldata = len(self.data)    #     if alldata > 0:    #         gnum = self.grid_out.GetNumberRows()  # 删除所有行↓    #         if gnum > 0:    #             self.grid_out.DeleteRows(0,gnum)  # 根据总行数循环删除第一行↑    #         row = 0    #         self.progress_bar.SetValue(0)    #         self.progress_bar.SetRange(alldata)    #         pr = 0    #         for m in self.data:    #             datas = eval(str(m))    #             if self.comb_users.GetValue() == '<All>' or self.comb_users.GetValue() == datas[4]:    #                 col = 0    #                 self.grid_out.AppendRows()  # 表格逐一添加新行    #                 for d in datas:    #                     if NET:    #                         if col == 4 and self.r.hexists('USERS', d):    #                             d = self.r.hget('USERS', d)    #                     self.grid_out.SetCellValue(row, col, d)    #                     self.grid_out.SetCellBackgroundColour(row, 6, wx.Colour(255, 210, 230))    #                     self.grid_out.SetCellBackgroundColour(row, 2, wx.Colour(255, 240, 190))    #                     self.grid_out.SetCellBackgroundColour(row, 4, wx.Colour(225, 250, 240))    #                     self.grid_out.SetCellBackgroundColour(row, 0, wx.Colour(225, 225, 225))    #                     col += 1    #                 row += 1    #                 pr+=1    #                 # wx.Yield()    #             pr+=1    #             self.progress_bar.SetValue(pr)    #         self.ResetWinSize(pr)    # def Esc_Stop(self,event):   #快捷键：ESC    #     if event.GetKeyCode() == wx.WXK_ESCAPE:    #         self.StartStop = False  #停止    #     event.Skip()    def del_MemData(self,event):        R_Data.clear()        self.member_use.SetLabel(f'[0 : 0]')        self.panel.Layout()        self.get_Data_list()        self.text_label.SetLabel("(缓存已删除)")    def save_LocalData(self, event):        if NET:            dlg = wx.MessageDialog(self, "确定保存选择的数据库存档吗？保存本地存档可以大幅加快搜索速度。", "[本地存档]", wx.YES_NO | wx.ICON_QUESTION)            result = dlg.ShowModal()            dlg.Destroy()            if result == wx.ID_YES:                selected_indices = self.list_2.GetSelections()                if selected_indices:                    selected_items = [self.list_2.GetString(index) for index in selected_indices]                    scount = len(selected_items)                    if scount > 0:                        self.text_label.SetLabel('正在创建存档:')                        for p in selected_items:                            self.progress_bar.SetValue(0)                            pp = str(p).split(' → ')[0]                            if pp[:4] != 'dif_':                                if '\\' in pp:                                    npp = pp.replace('\\', '!')                                else:                                    npp = pp                                if ':' in npp:                                    npp = npp.replace(':','=')                                print(npp)                                self.progress_bar.SetRange(self.r.hlen(pp))                                pr = 0                                redis_s = self.r.hvals(pp)                                R_Data[pp] = redis_s  # 获取所有的member成员                                aaa = []                                for i in redis_s:                                    aaa.append(i.decode("utf-8"))                                    pr += 1                                    self.progress_bar.SetValue(pr)                                wx.Yield()                                with open(rf"{npp}.json", "w") as json_file:                                    json.dump(aaa, json_file)                            else:                                dlg=wx.MessageDialog(self, f'查重类型数据不能在这里存档，可以在文件查重菜单中点击相应查重路径进行存档\n{pp[4:]}', "[本地存档]", wx.OK | wx.ICON_WARNING)                                dlg.ShowModal()                        self.text_label.SetLabel('(创建存档完成)')                        self.member_use.SetLabel(f'[{len(R_Data)} : **]')                        self.panel.Layout()                        self.r.close()                        self.get_Data_list()    def del_LocalData(self,event):        dlg = wx.MessageDialog(self, "确定删除本地数据库存档吗？删除后在下次启动软件点搜索时会下载服务器上最新的数据。", "[删除存档]",                               wx.YES_NO | wx.ICON_QUESTION)        result = dlg.ShowModal()        dlg.Destroy()        if result == wx.ID_YES:            selected_indices = self.list_2.GetSelections()            if selected_indices:                selected_items = [self.list_2.GetString(index) for index in selected_indices]                scount = len(selected_items)                if scount>0:                    for p in selected_items:                        pp = str(p).split(' → ')[0]                        if '\\' in pp:                            npp = pp.replace('\\', '!')                        else:                            npp = pp                        if ':' in npp:                            npp = npp.replace(':', '=')                        if os.path.exists(f'{npp}.json'):                            os.remove(f'{npp}.json')                        try:                            R_Data.pop(pp)  #删除对应缓存                        except:                            pass                    self.get_Data_list()                    self.get_dif(self)    SoftSearch = False    def search_Enter(self,event):        self.SoftSearch = True        self.search_Data_list()    def Sel_Size_Save(self,event):        try:            int(event.GetString())            conf.set('set_DS', 'Sel_Size_Save', event.GetString())        except:            dlg = wx.MessageDialog(self, "必须输入整数", "设置文件大小", wx.ICON_QUESTION)            dlg.ShowModal()            dlg.Destroy()            self.sel_size.SetValue(conf.get('set_DS', 'Sel_Size_Save'))    # def search_Enter(self,event):    #     row = 0    #     self.progress_bar.SetRange(120)    #     self.progress_bar.SetValue(0)    #     for i in range(1,120):    #         if self.r.hexists('vic.zeng_\\\\192.168.10.38\\自研产品部\\S1产品部\\二之国：交错世界\美术相关\\', f'MD5异常:{i}'):    #             rr=self.r.hget('vic.zeng_\\\\192.168.10.38\\自研产品部\\S1产品部\\二之国：交错世界\美术相关\\', f'MD5异常:{i}')    #             ppp = eval(rr.decode('utf-8'))    #             # has = self.calculate_md5(ppp[1])    #             # if 'MD5异常' not in has:    #             #     ppp[6]=has    #             self.r.hdel('vic.zeng_\\\\192.168.10.38\\自研产品部\\S1产品部\\二之国：交错世界\美术相关\\', f'MD5异常:{i}')    #             #     self.r.hset('vic.zeng_\\\\192.168.10.38\\自研产品部\\S1产品部\\二之国：交错世界\美术相关\\', has, str(ppp))    #             #     print(ppp)    #             self.grid_out.AppendRows()    #             col = 0    #             for d in ppp:    #                 self.grid_out.SetCellValue(row, col, d)    #                 col += 1    #             self.grid_out.SetCellBackgroundColour(row, 6, wx.Colour(255, 210, 230))    #             self.grid_out.SetCellBackgroundColour(row, 2, wx.Colour(255, 240, 190))    #             self.grid_out.SetCellBackgroundColour(row, 4, wx.Colour(225, 250, 240))    #             self.grid_out.SetCellBackgroundColour(row, 0, wx.Colour(225, 225, 225))    #         else:    #             print(f'MD5异常:{i}')    #             self.grid_out.AppendRows()    #             self.grid_out.SetCellValue(row, 6, f'MD5异常:{i}')    #         wx.Yield()    #         row += 1    #         self.progress_bar.SetValue(row)    #    #     self.ResetWinSize(row)    def search_Button(self,event):        self.SoftSearch = False        self.SelDif = False        self.search_Data_list()        if search_count:            if conf.has_option('search_text', 'current'):                oldt = conf.get('search_text', 'current')            else:                oldt = ''            path = self.combox_S.GetValue().strip()            if path != '' and oldt != path:                if conf.has_option('set_DS_t', 'path_count'):                    PC = int(conf.get('set_DS_t', 'path_count'))                else:                    PC = 0                same = True                if PC > 0:                    for i in range(PC):                        if conf.has_option('search_text', str(i)):                            his = conf.get('search_text', str(i))                        else:                            his = ''                        if path == his: same = False                    if same:                        conf.set('search_text', str(PC), path)                        conf.set('set_DS_t', 'path_count', str(PC + 1))                        self.combox_S.Append(path)                else:                    conf.set('set_DS_t', 'path_count', '1')                    conf.set('search_text', '0', path)                    self.combox_S.Append(path)            conf.set('search_text', 'current', path)            conf.write(open(setPath, 'w+', encoding="utf-8"))    def ResetWinSize(self,pr):        if self.grid_out.IsShown():            self.grid_out.AutoSizeColumns()            self.grid_out.Scroll(0, pr*2)            # self.grid_out.MakeCellVisible(pr, 0)  # 定位到选中行            screen_width = wx.Display(0).GetGeometry().GetWidth()  # 获取主显示器宽度            w = sum(self.grid_out.GetColSize(col) for col in range(self.grid_out.GetNumberCols())) + 130  # 获取Grid总宽度        else:            self.grid_out_v.AutoSizeColumns()            self.grid_out_v.Scroll(0, pr*2)            # self.grid_out_v.MakeCellVisible(pr, 0)  # 定位到选中行            screen_width = wx.Display(0).GetGeometry().GetWidth()  # 获取主显示器宽度            w = sum(self.grid_out_v.GetColSize(col) for col in range(self.grid_out_v.GetNumberCols())) + 130  # 获取Grid总宽度        if w > screen_width:            w = screen_width        if w < 1616: w = 1616        self.SetSize(wx.Size(w, self.GetSize()[1]))  # 设置主窗口大小        self.panel.Layout()    def show_all_Grid(self,event):  #显示所有文件        alldata = len(self.data)        selected_indices = self.list_2.GetSelections()        if selected_indices:            if alldata > 0:  # 判断是否有缓存                self.progress_bar.SetValue(0)                self.progress_bar.SetRange(alldata)                if self.grid_out.IsShown():                    R_S = self.grid_out.GetNumberRows()                    if R_S > 0:                        self.grid_out.DeleteRows(0, R_S)  # 根据总行数循环删除第一行↑                row = 0                FistDo = True                # self.grid_out.Freeze()  # 冻结网格                # temdata = self.data[:]  # 创建一个包含 self.data 内容的新列表副本                # self.grid_out.SetRowSize(0,28)  #设置第一行高度                # self.grid_out.SetTable(MyGridTable(temdata), takeOwnership=True)                # self.ResetWinSize(alldata)                # self.grid_out.AutoSize()                self.PerCopyFiles.clear()                selected_items = [self.list_2.GetString(index) for index in selected_indices]                dataname = str(selected_items[0]).split(' → ')[0]                dup_path = dataname.split('_', 1)  # 列表2路径名                if self.grid_out.IsShown():                    for k in self.data:                        if self.StartStop:                            fname = k[3].split('\\')                            dup_file = dup_path[1] + fname[len(fname) - 1]                            col = 0                            self.grid_out.AppendRows()  # 表格逐一添加新行                            for d in k:                                self.grid_out.SetCellValue(row, col, d)                                if col == 5:                                    if 'G' in d:                                        self.grid_out.SetCellTextColour(row, 5, wx.Colour(182, 0, 7))                                    if 'K' in d or 'B' in d:                                        self.grid_out.SetCellTextColour(row, 5, wx.Colour(0, 162, 7))                                col += 1                            if k[0] == 'D':                                self.grid_out.SetCellValue(row, 0, 'D')                                self.grid_out.SetCellTextColour(row, 0, wx.Colour(182, 180, 187))                                self.grid_out.SetCellBackgroundColour(row, 1, wx.Colour(225, 225, 225))                                self.grid_out.SetCellBackgroundColour(row, 2, wx.Colour(225, 225, 225))                                self.grid_out.SetCellBackgroundColour(row, 3, wx.Colour(232, 230, 237))                                self.grid_out.SetCellBackgroundColour(row, 4, wx.Colour(232, 230, 237))                                self.grid_out.SetCellBackgroundColour(row, 5, wx.Colour(232, 230, 237))                                self.grid_out.SetCellBackgroundColour(row, 0, wx.Colour(232, 230, 237))                                self.grid_out.SetCellBackgroundColour(row, 6, wx.Colour(215, 200, 250))                            else:                                self.grid_out.SetCellBackgroundColour(row, 6, wx.Colour(255, 210, 230))                            if not os.path.exists(k[3]):                                k[1]='del'                                self.grid_out.SetCellValue(row, 1, 'del')                                self.grid_out.SetCellBackgroundColour(row, 1, wx.Colour(232, 230, 230))                                self.grid_out.SetCellBackgroundColour(row, 6, wx.Colour(245, 240, 240))                                self.grid_out.SetCellTextColour(row, 2, wx.Colour(192, 160, 167))                                self.grid_out.SetCellTextColour(row, 3, wx.Colour(192, 160, 167))                                self.grid_out.SetCellTextColour(row, 5, wx.Colour(192, 160, 167))                                self.grid_out.SetCellTextColour(row, 6, wx.Colour(192, 160, 167))                            self.PerCopyFiles[row] = [k, k[3], dup_file, dataname]                            row += 1                            self.text_label.SetLabel(f'{row}/{alldata}')                            self.progress_bar.SetValue(row)                            if FistDo:                                self.ResetWinSize(row)                                FistDo = False                            if row % 32 == 0:                                wx.Yield()                        else:                            # self.grid_out.Thaw()  # 解冻网格并刷新                            self.text_label.SetLabel('<停止>')                            self.StartStop = True                            self.ResetWinSize(row)                            return                else:                    for k in self.data:                        if self.StartStop:                            fname = k[1].split('\\')                            dup_file = dup_path[1] + fname[len(fname) - 1]                            self.PerCopyFiles[row] = [k, k[1], dup_file, dataname]                        else:                            self.text_label.SetLabel('<停止>')                            self.StartStop = True                            self.ResetWinSize(row)                            return                    self.text_label.SetLabel('请稍候...')                    table = MyGridTable(self.data)                    self.grid_out_v.SetTable(table, True)                    self.grid_out_v.AutoSizeColumns()                    self.text_label.SetLabel('(完成)')                # self.grid_out.Thaw()  # 解冻网格并刷新                self.ResetWinSize(alldata)        else:            if self.cpy_btn.IsShown():                dlg = wx.MessageDialog(self, "请在右边列表选择数据库！", "[独一上传]", wx.ICON_QUESTION)                dlg.ShowModal()                dlg.Destroy()                return    def search_Data_list(self): #搜索数据库到输出到列表Grid        selected_indices = self.list_2.GetSelections()        if selected_indices:            selected_items = [self.list_2.GetString(index) for index in selected_indices]            scount = len(selected_items)            st = self.combox_S.GetValue()  # 搜索内容            if st == '':                dlg = wx.MessageDialog(self, "未设置搜索关键字，输入要检查路径关键字，避免数据量过大！是否继续列出所有数据？", "[设置搜索关键字]", wx.YES_NO | wx.ICON_QUESTION)                result = dlg.ShowModal()                dlg.Destroy()                if result == wx.ID_YES:                    pass                else:                    return            FistDo=True            self.ZhuangTai = 'SS'            global search_count, R_Data            rrr = 0            if self.grid_out.IsShown():                R_S = self.grid_out.GetNumberRows()            # 局部模糊查找，搜索内容回车事件过滤            if self.SoftSearch:                self.PerCopyFiles.clear()                alldata = len(self.data)                if alldata > 1: #判断是否有缓存                    self.progress_bar.SetValue(0)                    self.progress_bar.SetRange(alldata)                    if self.grid_out.IsShown():                        if R_S > 0:                            self.grid_out.DeleteRows(0, R_S)  # 删除所有行                    row = 0                    pr = 0                    dataname = str(selected_items[0]).split(' → ')[0]                    dup_path = dataname.split('_', 1)  # 列表2路径名                    data_v = []                    s_c=0                    for k in self.data:                        if self.StartStop:                            if self.fuzzy_search(st, k[3]):                                s_c+=1                                self.text_label2.SetLabel(f'找到 {s_c} 个')                                data_v.append(k)                                fname = k[3].split('\\')                                dup_file = dup_path[1] + fname[len(fname)-1]                                col = 0                                if self.grid_out.IsShown():                                    self.grid_out.AppendRows()  # 表格逐一添加新行                                    for d in k:                                        self.grid_out.SetCellValue(row, col, d)                                        if col == 5:                                            if 'G' in d:                                                self.grid_out.SetCellTextColour(row, 5, wx.Colour(182, 0, 7))                                            if 'K' in d or 'B' in d:                                                self.grid_out.SetCellTextColour(row, 5, wx.Colour(0, 162, 7))                                        col += 1                                    if k[0] == 'D':                                        self.grid_out.SetCellValue(row, 0, 'D')                                        self.grid_out.SetCellTextColour(row, 0, wx.Colour(182, 180, 187))                                        self.grid_out.SetCellBackgroundColour(row, 1, wx.Colour(225, 225, 225))                                        self.grid_out.SetCellBackgroundColour(row, 2, wx.Colour(225, 225, 225))                                        self.grid_out.SetCellBackgroundColour(row, 3, wx.Colour(232, 230, 237))                                        self.grid_out.SetCellBackgroundColour(row, 4, wx.Colour(232, 230, 237))                                        self.grid_out.SetCellBackgroundColour(row, 5, wx.Colour(232, 230, 237))                                        self.grid_out.SetCellBackgroundColour(row, 0, wx.Colour(232, 230, 237))                                        self.grid_out.SetCellBackgroundColour(row, 6, wx.Colour(215, 200, 250))                                    else:                                        self.grid_out.SetCellBackgroundColour(row, 6, wx.Colour(255, 210, 230))                                    if not os.path.exists(k[3]):                                        self.grid_out.SetCellValue(row, 1, 'del')                                        self.grid_out.SetCellBackgroundColour(row, 1, wx.Colour(232, 230, 230))                                        self.grid_out.SetCellBackgroundColour(row, 6, wx.Colour(245, 240, 240))                                        self.grid_out.SetCellTextColour(row, 2, wx.Colour(192, 160, 167))                                        self.grid_out.SetCellTextColour(row, 3, wx.Colour(192, 160, 167))                                        self.grid_out.SetCellTextColour(row, 5, wx.Colour(192, 160, 167))                                        self.grid_out.SetCellTextColour(row, 6, wx.Colour(192, 160, 167))                                self.PerCopyFiles[row] = [k, k[3], dup_file, dataname]                                row += 1                            self.text_label.SetLabel(f'{pr}')                            pr += 1                            self.progress_bar.SetValue(pr)                            if pr % 32 == 0:                                wx.Yield()                        else:                            self.text_label.SetLabel('<过滤停止>')                            if self.grid_out_v.IsShown():                                table = MyGridTable(data_v)                                self.grid_out_v.SetTable(table, True)                                self.grid_out_v.AutoSizeColumns()                            self.StartStop = True                            self.get_Data_list()                            self.cpy_btn.Hide()                            self.ResetWinSize(pr)                            if s_c == 0:                                dlg = wx.MessageDialog(self, f"没有找到[ {st} ]相关文件", "[搜索]", wx.ICON_QUESTION)                                dlg.ShowModal()                                dlg.Destroy()                            return                    if self.grid_out_v.IsShown():                        self.text_label.SetLabel('请稍候...')                        table = MyGridTable(data_v)                        self.grid_out_v.SetTable(table, True)                        self.grid_out_v.AutoSizeColumns()                        self.text_label.SetLabel('（完成）')                        self.ResetWinSize(pr)                    if s_c == 0:                        dlg = wx.MessageDialog(self, f"没有找到[ {st} ]相关文件", "[搜索]", wx.ICON_QUESTION)                        dlg.ShowModal()                        dlg.Destroy()                    rrr = pr            else:   #正常搜素                if scount > 0:                    if self.grid_out.IsShown():                        if R_S > 0:                            self.grid_out.DeleteRows(0, R_S)  # 删除全部表格                    row = 0 #注意：这个行ID需要在多个数据文件循环外，后面的搜索内容才不会将前面的替换                    search_count=False                    self.data=[]                    # self.edits_comb = []                    # user = []                    self.text_label.SetLabel('正在搜索:')                    self.progress_bar.SetValue(0)                    # readhis = True                    for p in selected_items:    #遍历列表2选中数据库                        pp = str(p).split(' → ')[0]                        if '\\' in pp:                            npp = pp.replace('\\','!')                        else:                            npp = pp                        if ':' in npp:                            npp = npp.replace(':','=')                        if pp not in R_Data:                    #读取本地<存档>json                            if os.path.exists(f'{npp}.json'):                                readhis = False                                with open(f'{npp}.json','r') as j_f:                                    tmp_Data = json.load(j_f)                                dict_data = dict()                                for t in tmp_Data:                                    if isinstance(t, bytes):  # 判断是否二进制                                        t = t.decode('utf-8')                                    t = eval(t)     #需要将字符转为数组                                    dict_data[t[6]]=t     #字典写入值                                R_Data[pp] = dict_data  #读取json再转换为set字典                            else:                                redis_s = self.r.hgetall(pp)  #获取所有的key 与 member成员(字典)                                R_Data[pp] = redis_s   #放入缓存                                readhis = True                        else:                            if pp[:4] == 'dif_':                                if os.path.exists(f'{npp}.json'):                                    readhis = False                                else:                                    readhis = True                            else:                                readhis = False     #无缓存时dif_关闭查重数据查找                        getAE = R_Data.get(pp)  #获取缓存内容                        self.progress_bar.SetRange(len(getAE))                        pr = 0                        s_c = 0                        for k, m in getAE.items(): #遍历set数据类型中的key(MD5值)与 member成员                            if self.StartStop:                                pr+=1                                self.progress_bar.SetValue(pr)                                if isinstance(m, bytes):    #判断是否二进制                                    m = m.decode('utf-8')                                mm = eval(str(m))  # 转换字符串为数组（将字符串作为代码执行）                                if pp[:4] == 'dif_' and readhis:                                    for i in mm[1]:  # 遍历重复文件数组                                        if st in i[0]:  # 初始查找                                            s_c += 1                                            self.text_label2.SetLabel(f'找到 {s_c} 个')                                            self.SelDif=True                                            if self.grid_out.IsShown():                                                self.grid_out.AppendRows()                                                self.grid_out.SetCellValue(row, 2, mm[0])                                                self.grid_out.SetCellValue(row, 3, i[0])                                                self.grid_out.SetCellValue(row, 5, mm[2])                                                self.grid_out.SetCellValue(row, 6, k)                                                if 'G' in mm[2]:                                                    self.grid_out.SetCellTextColour(row, 5, wx.Colour(182, 0, 7))                                                if 'K' in mm[2] or 'B' in mm[2]:                                                    self.grid_out.SetCellTextColour(row, 5, wx.Colour(0, 162, 7))                                                if i[1] == 'D':                                                    self.grid_out.SetCellValue(row, 0, 'D')                                                    self.grid_out.SetCellTextColour(row, 0, wx.Colour(182, 180, 187))                                                    self.grid_out.SetCellBackgroundColour(row, 1, wx.Colour(225, 225, 225))                                                    self.grid_out.SetCellBackgroundColour(row, 2, wx.Colour(225, 225, 225))                                                    self.grid_out.SetCellBackgroundColour(row, 3, wx.Colour(232, 230, 237))                                                    self.grid_out.SetCellBackgroundColour(row, 4, wx.Colour(232, 230, 237))                                                    self.grid_out.SetCellBackgroundColour(row, 5, wx.Colour(232, 230, 237))                                                    self.grid_out.SetCellBackgroundColour(row, 0, wx.Colour(232, 230, 237))                                                    self.grid_out.SetCellBackgroundColour(row, 6, wx.Colour(215, 200, 250))                                                else:                                                    self.grid_out.SetCellBackgroundColour(row, 6, wx.Colour(255, 210, 230))                                            isdel = ''                                            if not os.path.exists(i[0]):                                                isdel = 'del'                                                if self.grid_out.IsShown():                                                    self.grid_out.SetCellValue(row, 1, 'del')                                                    self.grid_out.SetCellBackgroundColour(row, 1, wx.Colour(232, 230, 230))                                                    self.grid_out.SetCellBackgroundColour(row, 6, wx.Colour(245, 240, 240))                                                    self.grid_out.SetCellTextColour(row, 2, wx.Colour(192, 160, 167))                                                    self.grid_out.SetCellTextColour(row, 3, wx.Colour(192, 160, 167))                                                    self.grid_out.SetCellTextColour(row, 5, wx.Colour(192, 160, 167))                                                    self.grid_out.SetCellTextColour(row, 6, wx.Colour(192, 160, 167))                                            row += 1                                            dd = [i[1], isdel, mm[0], i[0], '', mm[2], k]                                            self.data.append(dd)                                            if FistDo:                                                self.ResetWinSize(row)                                                FistDo = False                                else:                                    if st in mm[3]:    #初始查找：遍历正常文件数组                                        s_c += 1                                        self.text_label2.SetLabel(f'找到 {s_c} 个')                                        self.SelDif=False                                        # if mm[4] not in user and mm[4] != '':                                        #     user.append(mm[4])                                        if self.grid_out.IsShown():                                            col = 0                                            self.grid_out.AppendRows() #表格逐一添加新行                                            for d in mm:                                                # if NET:                                                #     if col == 4 and self.r.hexists('USERS', d):                                                #         d = self.r.hget('USERS', d) #读取作者数据                                                if col == 5:                                                    if 'G' in d:                                                        self.grid_out.SetCellTextColour(row, 5, wx.Colour(182, 0, 7))                                                    if 'K' in d or 'B' in d:                                                        self.grid_out.SetCellTextColour(row, 5, wx.Colour(0, 162, 7))                                                self.grid_out.SetCellValue(row, col, d)                                                col += 1                                            if mm[0] == 'D':                                                self.grid_out.SetCellValue(row, 0, 'D')                                                self.grid_out.SetCellTextColour(row, 0, wx.Colour(182, 180, 187))                                                self.grid_out.SetCellBackgroundColour(row, 1, wx.Colour(225, 225, 225))                                                self.grid_out.SetCellBackgroundColour(row, 2, wx.Colour(225, 225, 225))                                                self.grid_out.SetCellBackgroundColour(row, 3, wx.Colour(232, 230, 237))                                                self.grid_out.SetCellBackgroundColour(row, 4, wx.Colour(232, 230, 237))                                                self.grid_out.SetCellBackgroundColour(row, 5, wx.Colour(232, 230, 237))                                                self.grid_out.SetCellBackgroundColour(row, 0, wx.Colour(232, 230, 237))                                                self.grid_out.SetCellBackgroundColour(row, 6, wx.Colour(215, 200, 250))                                            else:                                                self.grid_out.SetCellBackgroundColour(row, 6, wx.Colour(255, 210, 230))                                            if not os.path.exists(mm[3]):                                                mm[1]='del'                                                self.grid_out.SetCellValue(row, 1, 'del')                                                self.grid_out.SetCellBackgroundColour(row, 1, wx.Colour(232, 230, 230))                                                self.grid_out.SetCellBackgroundColour(row, 6, wx.Colour(245, 240, 240))                                                self.grid_out.SetCellTextColour(row, 2, wx.Colour(192, 160, 167))                                                self.grid_out.SetCellTextColour(row, 3, wx.Colour(192, 160, 167))                                                self.grid_out.SetCellTextColour(row, 5, wx.Colour(192, 160, 167))                                                self.grid_out.SetCellTextColour(row, 6, wx.Colour(192, 160, 167))                                            row+=1                                            if FistDo:                                                self.ResetWinSize(row)                                                FistDo = False                                        self.data.append(mm) #暂存搜索数据，用于过滤显示                                if pr % 400 == 0:                                    wx.Yield()  #等待界面更新后再继续循环                            else:   # Esc                                self.text_label.SetLabel('<搜索停止>')                                if row > 0:                                    search_count = True                                    # for u in user:                                    #     if NET:                                    #         if not self.r.hexists('USERS', u):  # 判断Hash数据成员是否存在                                    #             newname = str(u).split('\\')[1]                                    #             self.r.hset('USERS', u, newname)  # 写入Hash数据成员                                rrr = pr                                if self.grid_out_v.IsShown():                                    table = MyGridTable(self.data)                                    self.grid_out_v.SetTable(table, True)                                    self.grid_out_v.AutoSizeColumns()                                self.StartStop = True                                AEsize = self.Sizeofsize(self.get_size(R_Data))                                self.member_use.SetLabel(f'[{len(R_Data)} : {AEsize}]')                                self.get_Data_list()                                self.cpy_btn.Hide()                                self.ResetWinSize(rrr)                                if s_c == 0:                                    dlg = wx.MessageDialog(self, f"没有找到[ {st} ]相关文件", "[搜索]", wx.ICON_QUESTION)                                    dlg.ShowModal()                                    dlg.Destroy()                                return                        if s_c == 0:                            dlg = wx.MessageDialog(self, f"没有找到[ {st} ]相关文件", "[搜索]", wx.ICON_QUESTION)                            dlg.ShowModal()                            dlg.Destroy()                        rrr=pr                    # AEsize = self.Sizeofsize(sys.getsizeof(getAE))                #计算变量占用内存                    AEsize = self.Sizeofsize(self.get_size(R_Data))                    self.member_use.SetLabel(f'[{len(R_Data)} : {AEsize}]')                    self.text_label.SetLabel('(搜索完成)')                    if row > 0:                        search_count = True #搜索到内容时打开记录搜索关键字的开关                    if len(self.data)>0:                        if self.grid_out_v.IsShown():                            self.text_label.SetLabel('请稍候...')                            table = MyGridTable(self.data)                            self.grid_out_v.SetTable(table, True)                            # self.grid_out_v.ForceRefresh()                            self.grid_out_v.AutoSizeColumns()                            self.text_label.SetLabel('（完成）')                    # self.r.close()                    self.get_Data_list()                    self.cpy_btn.Hide()            self.msg_txt.SetLabel(NormalTex)            self.ResetWinSize(rrr)        else:            dlg = wx.MessageDialog(self, "请在右边列表选择数据库！", "[过滤搜索]", wx.ICON_QUESTION)            dlg.ShowModal()            dlg.Destroy()    def check_redis(self, host, password, sdb=1):  #检查服务器链接        global NET        self.text_label.SetLabel('正在链接数据库:')        try:            t = redis.Redis(host=host, port=6379, password=password, decode_responses=True)            t.ping()  # 发送一个 ping 命令来检查连接            # self.text_label.SetLabel('(数据库正常)')            self.r = redis.StrictRedis(host=host, port=6379, db=sdb)            self.setr = redis.StrictRedis(host=host, port=6379, db=0)   #专用于设置的数据库链接线            NET = True            return True        except:            self.text_label.SetLabel('<服务器异常>')            NET = False            return Falseapp = wx.App(False)frame = MyFrame(None, f"DupliceClicker v{vvv}{v2}")frame.Show()if not NET:    wx.CallAfter(frame.edit_ip, None)   #在界面类外部执行UI内函数    wx.CallAfter(frame.update, None)else:    wx.CallAfter(frame.update, None)app.MainLoop()